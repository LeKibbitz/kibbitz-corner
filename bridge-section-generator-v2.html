<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bridge Generator V2 - Public Display Optimized</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            overflow-x: auto;
            overflow-y: auto;
            transition: all 0.3s ease;
            color: #e0e0e0;
            position: relative;
        }

        /* Particle background effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(circle at 20% 80%, rgba(168, 85, 247, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(236, 72, 153, 0.1) 0%, transparent 50%);
            z-index: -1;
            pointer-events: none;
        }

        body.dark-mode {
            background: #1a1a1a !important;
            color: #e0e0e0 !important;
        }

        /* ALL TEXT uses same color as player names */
        .dark-mode .player-name,
        .dark-mode .table-header,
        .dark-mode .section-title,
        .dark-mode h1, .dark-mode h2, .dark-mode h3,
        .dark-mode p, .dark-mode span:not(.constraint-indicator),
        .header-content span,
        .section-banner,
        .section-letter,
        .section-stats,
        .section-stats-line,
        .ns-text,
        .eo-text,
        .position-indicator,
        .tournament-header,
        .header-title,
        .header-btn,
        .section-btn,
        .algo-btn,
        .section-control label,
        .algo-control label,
        body,
        * {
            color: #e0e0e0 !important;
        }

        /* Override white color anywhere */
        [style*="color: white"],
        [style*="color:#fff"],
        [style*="color:#ffffff"],
        [style*="color: #fff"],
        [style*="color: #ffffff"] {
            color: #e0e0e0 !important;
        }

        .dark-mode .table-card {
            background: #34495e;
            border-color: #4a6741;
        }

        .dark-mode .position {
            background: #2c3e50;
            border-color: #4a6741;
            color: #ecf0f1;
        }

        .dark-mode .player-name {
            color: #ecf0f1;
        }

        .dark-mode .tournament-header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
        }

        .dark-mode .section-title {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
        }

        .dark-mode .global-headers {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-color: #4a6741;
        }

        .dark-mode .section-stats {
            background: transparent;
            border: none;
        }

        .setup-mode {
            padding: 20px;
            height: 100vh;
            overflow-y: auto;
        }

        .display-mode {
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: auto;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: transparent;
            border-radius: 10px;
            overflow: hidden;
        }

        .mitchell-display {
            width: 100vw;
            height: 100vh;
            background: transparent;
            display: flex;
            flex-direction: column;
            position: relative;
            color: #e0e0e0;
        }

        .tournament-header {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            backdrop-filter: blur(30px);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #e0e0e0;
            padding: 20px 30px;
            box-shadow: 0 8px 40px rgba(99, 102, 241, 0.15), 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 100;
            border-radius: 0 0 20px 20px;
            position: relative;
            overflow: hidden;
        }

        .tournament-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 20%, rgba(168, 85, 247, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 70% 80%, rgba(59, 130, 246, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 100%;
            position: relative;
            z-index: 1;
        }

        .header-content span {
            font-size: 1.6em;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #e2e8f0 50%, #cbd5e1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
            flex: 1;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .section-control, .algo-control, .table-control {
            background: transparent;
            padding: 0;
            border: none;
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .section-control select, .table-control input {
            display: none;
        }

        .fullscreen-exit {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.6);
            padding: 6px 10px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.2s ease;
        }

        .fullscreen-exit:hover {
            color: rgba(255,255,255,0.95);
            transform: scale(1.2);
        }

        .header-controls {
            display: flex;
            gap: 4px;
            align-items: flex-end;
            padding: 5px 0;
        }

        /* Effet G√©nie MacOS Dock - Smooth */
        .header-btn, .section-btn, .algo-btn, .fullscreen-exit {
            background: transparent;
            color: rgba(255,255,255,0.6);
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 500;
            transition: transform 0.2s ease-out, color 0.15s ease, text-shadow 0.15s ease;
            white-space: nowrap;
            transform-origin: bottom center;
        }

        .header-btn:hover, .section-btn:hover, .algo-btn:hover {
            color: rgba(255,255,255,0.95);
            transform: scale(1.2) translateY(-2px);
            text-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* Effet voisin smooth */
        .header-btn:hover + .header-btn,
        .section-btn:hover + .section-btn,
        .algo-btn:hover + .algo-btn,
        .header-btn:has(+ .header-btn:hover),
        .section-btn:has(+ .section-btn:hover),
        .algo-btn:has(+ .algo-btn:hover) {
            transform: scale(1.08) translateY(-1px);
            color: rgba(255,255,255,0.7);
        }

        .header-btn.active, .section-btn.active, .algo-btn.active {
            color: #ffffff;
            font-weight: 700;
            text-shadow: 0 0 12px rgba(255,255,255,0.6);
        }

        .button-group {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            background: transparent;
            padding: 0;
            border: none;
        }

        .section-control label, .algo-control label {
            display: none;
        }

        /* S√©parateur dans header */
        .header-separator {
            color: rgba(255,255,255,0.2);
            font-size: 1.2em;
            padding: 0 5px;
            user-select: none;
        }

        /* Contr√¥le nombre de tables en HAUT du bandeau section */
        .table-count-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 8px 0;
            order: -1; /* Place en haut du bandeau */
        }

        .table-count-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 1em;
            cursor: pointer;
            padding: 2px 6px;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .table-count-btn:hover {
            color: rgba(255,255,255,0.95);
            transform: scale(1.3);
        }

        .table-count-display {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .table-count-value {
            font-size: 1.4em;
            font-weight: 700;
            min-width: 24px;
            text-align: center;
        }

        .table-icon {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* Section colors for table count */
        .section-a .table-count-value, .section-a .table-icon { color: #e9d5ff; text-shadow: 0 0 8px rgba(168, 85, 247, 0.5); }
        .section-b .table-count-value, .section-b .table-icon { color: #fce7f3; text-shadow: 0 0 8px rgba(236, 72, 153, 0.5); }
        .section-c .table-count-value, .section-c .table-icon { color: #cffafe; text-shadow: 0 0 8px rgba(6, 182, 212, 0.5); }

        /* Flash effect for modified counters */
        .table-count-value.modified {
            animation: flashModified 0.8s ease-in-out infinite;
        }

        @keyframes flashModified {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .section-a .table-count-value.modified {
            color: #c084fc;
            text-shadow: 0 0 15px rgba(168, 85, 247, 0.8);
        }
        .section-b .table-count-value.modified {
            color: #f472b6;
            text-shadow: 0 0 15px rgba(236, 72, 153, 0.8);
        }
        .section-c .table-count-value.modified {
            color: #22d3ee;
            text-shadow: 0 0 15px rgba(6, 182, 212, 0.8);
        }

        /* Cartouche de modification en attente */
        .pending-changes {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.95) 0%, rgba(236, 72, 153, 0.95) 100%);
            padding: 12px 24px;
            border-radius: 30px;
            display: flex;
            gap: 15px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            z-index: 1000;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        .pending-changes.hidden {
            display: none;
        }

        .pending-changes span {
            color: white;
            font-weight: 500;
            font-size: 0.95em;
        }

        .pending-changes button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .pending-changes button:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .pending-changes .regen-btn {
            background: rgba(39, 174, 96, 0.8);
        }

        .pending-changes .cancel-btn {
            background: rgba(231, 76, 60, 0.6);
        }

        .sections-grid {
            flex: 1;
            display: flex;
            gap: 40px;
            padding: 10px;
            padding-right: 10px;
            justify-content: center;
            align-items: flex-start;
            overflow-y: auto;
        }

        .sections-grid.two-sections {
            padding-right: 10px;
        }

        .sections-grid.three-sections {
            padding-right: 10px;
        }

        .three-sections .section-container {
            flex: 1;
            max-width: 33%;
        }

        .section-container {
            flex: 1;
            max-width: 50%;
        }

        .section-banner {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            width: 75px;
            margin-right: 20px;
            border-radius: 16px;
            box-shadow: none !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 0;
            gap: 5px;
            position: relative;
            overflow: hidden;
            border: none !important;
            backdrop-filter: none !important;
        }

        .section-letter {
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Inter', 'Helvetica Neue', sans-serif;
            font-weight: 800;
            font-size: clamp(2.5rem, 8vw, 4rem);
            line-height: 1;
            font-variation-settings: 'wght' 800, 'wdth' 100;
            writing-mode: horizontal-tb;
            text-align: center;
            letter-spacing: -0.05em;
            flex: 1;
            min-height: 60px;
        }

        .section-stats {
            padding: 15px 4px 10px 4px;
            font-size: 1rem;
            font-weight: 500;
            line-height: 1.4;
            text-align: center;
            width: 100%;
            background: transparent;
        }

        .section-stats-line {
            margin: 3px 0;
            font-size: 1em;
            font-weight: 500;
            text-align: center;
            opacity: 0.85;
            letter-spacing: 0.02em;
        }

        .section-stats-line:nth-child(1) {
            height: 0;
            display: none;
        }

        /* Labels NS/EO - subtle */
        .section-stats-line:nth-child(2),
        .section-stats-line:nth-child(4) {
            font-size: 0.9em;
            font-weight: 600;
            opacity: 0.75;
            letter-spacing: 0.1em;
        }

        /* Values - emphasized */
        .section-stats-line:nth-child(3),
        .section-stats-line:nth-child(5) {
            font-weight: 700;
            font-size: 1.3em;
            opacity: 1;
        }

        /* Section-specific text colors with nuances */
        .section-a .section-stats-line {
            color: #d8b4fe; /* Light purple - nuance of section A violet */
            text-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
        }
        .section-a .section-stats-line:nth-child(3),
        .section-a .section-stats-line:nth-child(5) {
            color: #f3e8ff; /* Brighter purple for values */
        }

        .section-b .section-stats-line {
            color: #fbcfe8; /* Light pink - nuance of section B rose */
            text-shadow: 0 0 10px rgba(236, 72, 153, 0.5);
        }
        .section-b .section-stats-line:nth-child(3),
        .section-b .section-stats-line:nth-child(5) {
            color: #fce7f3; /* Brighter pink for values */
        }

        .section-c .section-stats-line {
            color: #a5f3fc; /* Light cyan - nuance of section C */
            text-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }
        .section-c .section-stats-line:nth-child(3),
        .section-c .section-stats-line:nth-child(5) {
            color: #cffafe; /* Brighter cyan for values */
        }

        .section-title {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 8px;
            text-align: center;
            font-weight: bold;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 1.1em;
            display: none; /* Hidden by default, will be replaced by section-banner */
        }

        .section-name {
            flex: 1;
            text-align: center;
        }

        .section-ns-avg,
        .section-eo-avg {
            font-size: 0.9em;
            font-weight: normal;
            opacity: 0.9;
        }

        .section-ns-avg {
            text-align: left;
        }

        .section-eo-avg {
            text-align: right;
        }

        .section-container {
            display: flex;
            margin-bottom: 30px;
            align-items: stretch;
        }

        .section-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .tables-grid {
            flex: 1;
        }

        .section-averages {
            font-size: 0.85em;
            line-height: 1.4;
        }

        /* Hide amounts, IV, and payment info from main display */
        .player-amount, .iv-total, .payment-info {
            display: none;
        }

        /* Show details on hover or click */
        .position.show-details .player-amount,
        .position.show-details .iv-total,
        .position.show-details .payment-info {
            display: inline-block;
        }

        /* Payment info styling */
        .payment-info {
            font-size: 0.8em;
            color: #e74c3c;
            font-weight: bold;
            margin-left: 5px;
        }

        /* Click indicator for team cards */
        .position.clickable {
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .position.clickable:hover {
            transform: scale(1.02);
        }

        /* Drag and drop destination styling */
        .table-card.drag-target {
            border: 2px solid #a855f7 !important;
            border-radius: 18px !important;
            box-shadow: 0 8px 30px rgba(168, 85, 247, 0.5) !important;
            transform: scale(1.03);
            background: rgba(168, 85, 247, 0.15) !important;
        }

        .section-b .table-card.drag-target {
            border-color: #ec4899 !important;
            box-shadow: 0 8px 30px rgba(236, 72, 153, 0.5) !important;
            background: rgba(236, 72, 153, 0.15) !important;
        }

        .section-c .table-card.drag-target {
            border-color: #06b6d4 !important;
            box-shadow: 0 8px 30px rgba(6, 182, 212, 0.5) !important;
            background: rgba(6, 182, 212, 0.15) !important;
        }

        /* Section colors matching Kibbitz Corner aesthetic */
        .section-a .section-title,
        .section-a .section-banner {
            background: linear-gradient(135deg, #a855f7 0%, #8b5cf6 100%);
        }

        .section-b .section-title,
        .section-b .section-banner {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
        }

        .section-c .section-title,
        .section-c .section-banner {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }

        /* .section-stats is defined earlier with section-specific colors */

        .stat-line {
            margin: 2px 0;
        }

        /* Relais - nuance subtile par rapport aux autres cartouches */
        .relais-position {
            background: linear-gradient(135deg, rgba(60, 70, 60, 0.95) 0%, rgba(50, 60, 50, 0.95) 100%) !important;
            border-color: rgba(120, 140, 100, 0.6) !important;
        }

        .section-a .relais-position {
            background: linear-gradient(135deg, rgba(90, 60, 100, 0.4) 0%, rgba(70, 50, 80, 0.4) 100%) !important;
            border-color: rgba(168, 85, 247, 0.4) !important;
        }

        .section-b .relais-position {
            background: linear-gradient(135deg, rgba(100, 50, 70, 0.4) 0%, rgba(80, 40, 60, 0.4) 100%) !important;
            border-color: rgba(236, 72, 153, 0.4) !important;
        }

        .section-c .relais-position {
            background: linear-gradient(135deg, rgba(40, 80, 90, 0.4) 0%, rgba(30, 70, 80, 0.4) 100%) !important;
            border-color: rgba(6, 182, 212, 0.4) !important;
        }

        .relais-position .empty-position {
            color: rgba(255,255,255,0.5);
            font-weight: bold;
            font-style: italic;
        }

        .tables-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            flex: 1;
        }

        .table-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(20px);
            display: flex;
            min-height: 60px;
            margin-bottom: 8px;
            position: relative;
        }

        .table-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 16px;
            padding: 1px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: xor;
            pointer-events: none;
        }

        /* Section-specific table colors matching section banners EXACTLY */
        .section-a .table-card {
            border-left: 4px solid #a855f7;
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(139, 92, 246, 0.15) 100%);
            color: #e0e0e0;
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.25);
            border: 1px solid rgba(168, 85, 247, 0.2);
        }

        .section-b .table-card {
            border-left: 4px solid #ec4899;
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.15) 0%, rgba(219, 39, 119, 0.15) 100%);
            color: #e0e0e0;
            box-shadow: 0 4px 20px rgba(236, 72, 153, 0.25);
            border: 1px solid rgba(236, 72, 153, 0.2);
        }

        .section-c .table-card {
            border-left: 4px solid #06b6d4;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.15) 0%, rgba(8, 145, 178, 0.15) 100%);
            color: #e0e0e0;
            box-shadow: 0 4px 20px rgba(6, 182, 212, 0.25);
            border: 1px solid rgba(6, 182, 212, 0.2);
        }

        /* Dark mode section table colors */
        .dark-mode .section-a .table-card {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-left-color: #3498db;
        }

        .dark-mode .section-b .table-card {
            background: linear-gradient(135deg, #2c3e50 0%, #27ae60 100%);
            border-left-color: #2ecc71;
        }

        .dark-mode .section-c .table-card {
            background: linear-gradient(135deg, #2c3e50 0%, #e74c3c 100%);
            border-left-color: #e74c3c;
        }

        .table-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.3);
        }

        .section-a .table-card:hover {
            box-shadow: 0 12px 40px rgba(168, 85, 247, 0.4);
            border-color: rgba(168, 85, 247, 0.4);
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
        }

        .section-b .table-card:hover {
            box-shadow: 0 12px 40px rgba(236, 72, 153, 0.4);
            border-color: rgba(236, 72, 153, 0.4);
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.2) 0%, rgba(219, 39, 119, 0.2) 100%);
        }

        .section-c .table-card:hover {
            box-shadow: 0 12px 40px rgba(6, 182, 212, 0.4);
            border-color: rgba(6, 182, 212, 0.4);
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.2) 0%, rgba(8, 145, 178, 0.2) 100%);
        }

        .table-header {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            padding: 10px 12px;
            text-align: center;
            font-weight: 600;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 14px 14px 0 0;
            min-height: 40px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Section-specific table header colors matching section banners EXACTLY */
        .section-a .table-header {
            background: linear-gradient(135deg, #a855f7 0%, #8b5cf6 100%) !important;
            color: #e0e0e0 !important;
            font-weight: 700 !important;
            text-shadow: none !important;
            box-shadow: none !important;
            border: none !important;
            border-radius: 16px !important;
        }

        .section-b .table-header {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%) !important;
            color: #e0e0e0 !important;
            font-weight: 700 !important;
            text-shadow: none !important;
            box-shadow: none !important;
            border: none !important;
            border-radius: 16px !important;
        }

        .section-c .table-header {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%) !important;
            color: #e0e0e0 !important;
            font-weight: 700 !important;
            text-shadow: none !important;
            box-shadow: none !important;
            border: none !important;
            border-radius: 16px !important;
        }

        /* Single section inherits from section-a/b/c - no override needed */
        /* Table headers now always follow their parent section color */

        .table-positions {
            display: flex;
            flex: 1;
        }

        .global-headers {
            display: flex;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #dee2e6;
            border-radius: 6px;
            margin-bottom: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }

        .global-header-spacer {
            width: 60px;
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px 0 0 4px;
            font-size: 0.9em;
        }

        .global-header {
            flex: 1;
            padding: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ns-header {
            border-right: 1px solid #dee2e6;
            color: #007bff;
        }

        .eo-header {
            color: #dc3545;
        }

        .position {
            flex: 1;
            padding: 3px 5px;
            border: 1px solid #e9ecef;
            background: #f8f9fa;
            transition: all 0.3s ease;
            cursor: grab;
            min-height: var(--position-height, 45px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            position: relative;
            font-size: 0.9em;
        }

        /* Hover √©quipes: bordure lumineuse + scintillement, pas de changement de background */
        .position:hover {
            border-color: rgba(255,255,255,0.6);
            box-shadow: 0 0 12px rgba(255,255,255,0.3), inset 0 0 0 1px rgba(255,255,255,0.2);
            animation: shimmer 1.5s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { box-shadow: 0 0 12px rgba(255,255,255,0.3), inset 0 0 0 1px rgba(255,255,255,0.2); }
            50% { box-shadow: 0 0 18px rgba(255,255,255,0.5), inset 0 0 0 1px rgba(255,255,255,0.35); }
        }

        /* Hover couleurs par section */
        .section-a .position:hover {
            border-color: rgba(168, 85, 247, 0.8);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.4);
        }
        .section-b .position:hover {
            border-color: rgba(236, 72, 153, 0.8);
            box-shadow: 0 0 15px rgba(236, 72, 153, 0.4);
        }
        .section-c .position:hover {
            border-color: rgba(6, 182, 212, 0.8);
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
        }

        .position.dragging {
            opacity: 0.5;
            cursor: grabbing;
            transform: rotate(3deg) scale(1.05);
        }

        /* Drop target pendant le drag - avec IV visible */
        .position.drop-target {
            border-color: rgba(39, 174, 96, 0.9);
            border-width: 2px;
            border-style: solid;
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.5);
            animation: pulse-target 0.8s ease-in-out infinite;
        }

        @keyframes pulse-target {
            0%, 100% { box-shadow: 0 0 15px rgba(39, 174, 96, 0.4); }
            50% { box-shadow: 0 0 25px rgba(39, 174, 96, 0.7); }
        }

        /* IV overlay sur les destinations pendant le drag */
        .position.drop-target::after {
            content: attr(data-iv);
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 0.75em;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
            z-index: 10;
        }

        .position.similarity-green {
            background: #d4edda;
            border-color: #28a745;
            animation: pulse-green 0.8s infinite;
        }

        .position.similarity-orange {
            background: #fff3cd;
            border-color: #ffc107;
            animation: pulse-orange 0.8s infinite;
        }

        .position.similarity-red {
            background: #f8d7da;
            border-color: #dc3545;
            animation: pulse-red 0.8s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.4); }
            50% { box-shadow: 0 0 15px rgba(40, 167, 69, 0.8); }
        }

        @keyframes pulse-orange {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 193, 7, 0.4); }
            50% { box-shadow: 0 0 15px rgba(255, 193, 7, 0.8); }
        }

        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 5px rgba(220, 53, 69, 0.4); }
            50% { box-shadow: 0 0 15px rgba(220, 53, 69, 0.8); }
        }


        .ns-position {
            border-right: 1px solid #dee2e6;
        }

        .eo-position {
            border-left: 1px solid #dee2e6;
        }

        .pair-info {
            display: flex;
            align-items: center;
            height: 100%;
            padding: 2px;
        }

        .player-names {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            line-height: 1.1;
        }

        .player-name {
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.4em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.4;
            display: flex;
            justify-content: space-between;
            align-items: center;
            letter-spacing: 0.5px;
        }

        /* Adaptive font size for long names */
        .player-name.name-long {
            font-size: 1.2em;
        }
        .player-name.name-very-long {
            font-size: 1em;
        }

        .player-amount {
            font-size: 0.75em;
            color: #666;
            margin-left: 4px;
            flex-shrink: 0;
        }

        /* Payment status colors */
        .payment-full .player-name {
            color: #27ae60 !important; /* Green for fully paid */
            font-weight: 600;
        }

        .payment-partial .player-name {
            color: #f39c12 !important; /* Orange for partial payment */
            font-weight: 600;
        }

        .payment-none .player-name {
            color: #e74c3c !important; /* Red for no payment */
            font-weight: 600;
        }

        /* Dark mode payment colors - FONT ONLY */
        .dark-mode .payment-partial .player-name {
            color: #f7dc6f !important;
            font-weight: 600;
        }

        .dark-mode .payment-none .player-name {
            color: #f1948a !important;
            font-weight: 600;
        }

        .dark-mode .payment-full .player-name {
            color: #a7f3d0 !important; /* Emerald-200 for fully paid */
            font-weight: 600;
        }

        .iv-total {
            font-weight: bold;
            color: #8B5A96;
            font-size: 0.9em;
            margin-left: 6px;
            min-width: 40px;
            text-align: center;
        }

        .ns-constraint .constraint-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #1976d2;
            margin-right: 8px;
            font-size: 0.7em;
            min-width: 25px;
            background: rgba(33, 150, 243, 0.1);
            border-radius: 4px;
            padding: 2px;
        }

        .dark-mode .ns-constraint .constraint-indicator {
            color: #3498db;
            background: rgba(52, 152, 219, 0.2);
        }

        .ns-constraint .pair-info {
            display: flex;
            align-items: center;
        }

        .ns-constraint .lock-icon {
            font-size: 1em;
            margin-bottom: 1px;
        }

        .ns-constraint .ns-text {
            font-size: 0.6em;
            font-weight: bold;
        }

        .constraint-indicator {
            display: none;
        }

        .position-indicator {
            position: absolute;
            top: 4px;
            right: 6px;
            font-size: 0.7em;
            font-weight: 700;
            opacity: 0.8;
            z-index: 2;
        }

        .ns-text, .eo-text {
            font-size: 0.8em;
            font-weight: bold;
        }

        .lock-icon {
            font-size: 1.2em;
            margin-bottom: 2px;
        }

        .ns-text {
            font-size: 0.8em;
            font-weight: bold;
        }

        /* Section-specific NS/EO text colors */
        .section-a .ns-text,
        .section-a .eo-text,
        .section-a .position {
            color: #e0e0e0;
        }

        .section-b .ns-text,
        .section-b .eo-text,
        .section-b .position {
            color: #e0e0e0;
        }

        .section-c .ns-text,
        .section-c .eo-text,
        .section-c .position {
            color: #e0e0e0;
        }

        /* Section-specific text shadows for better visibility */
        .section-a .ns-text,
        .section-a .eo-text {
            text-shadow: 0 1px 3px rgba(168, 85, 247, 0.5);
        }

        .section-b .ns-text,
        .section-b .eo-text {
            text-shadow: 0 1px 3px rgba(236, 72, 153, 0.5);
        }

        .section-c .ns-text,
        .section-c .eo-text {
            text-shadow: 0 1px 3px rgba(6, 182, 212, 0.5);
        }

        .position:hover {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .position.clickable {
            cursor: pointer;
        }

        .constraint-controls {
            position: fixed;
            bottom: 20px;
            right: 15px;
            z-index: 300;
            display: none;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .page-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 300;
            display: none;
            background: rgba(255,255,255,0.95);
            padding: 8px 16px;
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            font-weight: bold;
        }

        .page-indicator {
            color: #8B5A96;
            margin: 0 10px;
        }

        .tables-grid.paginated {
            transition: transform 0.5s ease;
        }

        .dark-mode .constraint-controls,
        .dark-mode .page-controls {
            background: rgba(44, 62, 80, 0.95);
            color: #ecf0f1;
        }

        .constraint-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 2px;
        }

        .constraint-btn:hover {
            background: #218838;
        }

        .empty-position {
            text-align: center;
            color: #adb5bd;
            font-style: italic;
            padding: 8px 4px;
            font-size: 0.75em;
        }

        /* Old controls styles removed - now in header */

        .single-section .sections-grid {
            justify-content: center;
        }

        .single-section .section-container {
            max-width: 80%;
        }

        .single-section .tables-grid {
            max-width: 900px;
            margin: 0 auto;
        }

        /* Two-column layout for single section with many tables */
        .single-section.two-columns .tables-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            max-width: 1600px;
            align-items: flex-start;
        }

        .single-section.two-columns .column-left,
        .single-section.two-columns .column-right {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .single-section.two-columns .section-container {
            max-width: 95%;
        }

        /* Responsive: Fall back to single column on small screens */
        @media (max-width: 1200px) {
            .single-section.two-columns .tables-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        .header {
            background: linear-gradient(135deg, #8B5A96 0%, #E91E63 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        textarea {
            width: 100%;
            height: 200px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #8B5A96;
        }

        .controls {
            display: flex;
            gap: 20px;
            align-items: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .section-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 16px;
        }

        button {
            background: linear-gradient(135deg, #8B5A96 0%, #E91E63 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .results {
            margin-top: 30px;
        }

        .section {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }

        .section-header {
            background: linear-gradient(135deg, #8B5A96 0%, #E91E63 100%);
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
        }

        .pairs-table {
            width: 100%;
            border-collapse: collapse;
        }

        .pairs-table th,
        .pairs-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .pairs-table th {
            background: #f8f9fa;
            font-weight: bold;
        }

        .pairs-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .pairs-table tr:hover {
            background: #e9ecef;
        }

        .player {
            margin: 5px 0;
        }

        /* .player-name defined earlier with larger font for readability */

        .player-info {
            font-size: 0.9em;
            color: #666;
        }

        .iv-score {
            font-weight: bold;
            color: #8B5A96;
        }

        .print-button {
            margin-top: 20px;
            background: #28a745;
        }

        @media print {
            body {
                background: white;
                padding: 0;
            }

            .container {
                box-shadow: none;
                border-radius: 0;
            }

            .input-section,
            .controls,
            .print-button,
            .controls-bar {
                display: none !important;
            }

            .mitchell-display {
                background: white;
            }

            .table-card {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <div id="setupView" class="setup-mode" style="display: none;">
        <div class="container">
            <div class="header">
                <h1>üÉè Bridge Generator V2 - Public Display</h1>
                <p>TBD: Algo OK, Display OK, Multi-section OK, Need small fixes</p>
                <p style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
                    Restful colors, highly visible for public use, section management
                </p>
            </div>

            <div class="content">
                <div class="input-section">
                    <h3>1. Coller les donn√©es du tournoi</h3>
                    <textarea id="tournamentData" placeholder="Collez ici les donn√©es copi√©es depuis ffbridge.fr..."></textarea>

                    <div class="controls">
                        <div class="section-selector">
                            <label for="sectionCount">Nombre de sections:</label>
                            <select id="sectionCount">
                                <option value="1">1 section</option>
                                <option value="2">2 sections</option>
                                <option value="3">3 sections</option>
                            </select>
                        </div>

                        <div class="section-selector">
                            <label for="entryFee">Montant inscription:</label>
                            <input type="number" id="entryFee" value="5.00" step="0.50" min="0" style="width: 80px; padding: 5px; text-align: center;">‚Ç¨
                        </div>

                        <button id="generateButton" onclick="generateSections()" type="button">
                            G√©n√©rer les sections
                        </button>

                        <button onclick="loadTestData()" style="background: #6c757d; margin-left: 10px;">
                            üìã Test 35 paires
                        </button>
                        <button onclick="loadTestData80()" style="background: #17a2b8; margin-left: 10px;">
                            üìã Test 80 paires
                        </button>

                        <button onclick="debugDisplay()" style="background: #dc3545; margin-left: 10px;">
                            üêõ Debug
                        </button>

                        <button onclick="testJS()" style="background: #ffc107; margin-left: 10px;">
                            ‚ö° Test JS
                        </button>
                    </div>

                    <div id="status" class="status" style="display: none;"></div>
                </div>

                <div id="results" class="results" style="display: none;">
                    <h3>2. Mise en place des sections</h3>
                    <div id="sectionsContainer"></div>
                    <button class="print-button" onclick="window.print()">üñ®Ô∏è Imprimer</button>
                    <button onclick="showMitchellDisplay()" style="background: #28a745; margin-left: 10px;">
                        üì∫ Affichage Mitchell
                    </button>
                    <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 0.9em;">
                        <h5>üîó Automatisation & Capture</h5>
                        <p>Outils d'automatisation pour ffbridge.fr et capture d'√©cran :</p>
                        <div style="margin: 10px 0;">
                            <button onclick="showFFBExtractor()" style="background: #007bff; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-right: 8px;">
                                üìã Extracteur FFB
                            </button>
                            <button onclick="initScreenCapture()" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-right: 8px;">
                                üì∑ Capture √âcran
                            </button>
                            <button onclick="setupN8NIntegration()" style="background: #6f42c1; color: white; border: none; padding: 6px 12px; border-radius: 4px;">
                                üåê Config n8n
                            </button>
                        </div>
                        <div id="automationHelp" style="display: none; background: #fff; padding: 10px; border-radius: 4px; border: 1px solid #dee2e6; margin-top: 10px;">
                            <!-- Dynamic help content -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="mitchellView" class="display-mode mitchell-display" style="display: block;">
        <div class="tournament-header">
            <div class="header-content">
                <span id="tournamentTitle">Tournoi #1</span>
                <div class="header-controls">
                    <div class="section-control">
                        <label>Sections:</label>
                        <div class="button-group">
                            <button id="sections1" class="section-btn active" onclick="setSectionCount(1)">1</button>
                            <button id="sections2" class="section-btn" onclick="setSectionCount(2)">2</button>
                            <button id="sections3" class="section-btn" onclick="setSectionCount(3)">3</button>
                        </div>
                    </div>
                    <div class="algo-control">
                        <label>Algo:</label>
                        <div class="button-group">
                            <button id="algo147" class="algo-btn active" onclick="setAlgorithm('1-4-7')" title="Algorithme 1-4-7">147</button>
                            <button id="algoNew" class="algo-btn" onclick="setAlgorithm('TBD')" title="Algorithme √©quilibr√©">?</button>
                        </div>
                    </div>
                    <span class="header-separator">|</span>
                    <button class="header-btn" onclick="showConstraintControls()" title="Contraintes NS fixe">üîí</button>
                    <button class="header-btn" onclick="window.print()" title="Imprimer">üñ®</button>
                    <span class="header-separator">|</span>
                    <button class="fullscreen-exit" onclick="closeToConfig()" id="fullscreenExit" title="Retour config">‚úï</button>
                </div>
            </div>
        </div>

        <div class="constraint-controls" id="constraintControls">
            <div style="margin-bottom: 8px; font-weight: bold; font-size: 0.9em;">Contraintes NS</div>
            <div style="font-size: 0.8em; margin-bottom: 8px;" id="constraintCount">0 paire(s) marqu√©e(s)</div>
            <button class="constraint-btn" onclick="redistributeWithConstraints()">üîÑ Redistribuer</button>
            <button class="constraint-btn" onclick="clearConstraints()" style="background: #dc3545;">Effacer tout</button>
        </div>

        <!-- Cartouche de modifications en attente -->
        <div class="pending-changes hidden" id="pendingChanges">
            <span>‚ö†Ô∏è Modifications non appliqu√©es</span>
            <button class="regen-btn" onclick="applyPendingChanges()">‚úì Appliquer</button>
            <button class="cancel-btn" onclick="cancelPendingChanges()">‚úï Annuler</button>
        </div>

        <div id="mitchellContainer" class="sections-grid">
        </div>

        <div class="page-controls" id="pageNavigation" style="display: none;">
            <button onclick="prevPage()" style="background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 4px;">‚óÄ</button>
            <span class="page-indicator" id="pageIndicator">Page 1/1</span>
            <button onclick="nextPage()" style="background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 4px;">‚ñ∂</button>
        </div>

    </div>

    <script>
        console.log('üîç DEBUG: JavaScript is loading...');

        let parsedPairs = [];
        let mitchellData = [];
        let draggedPair = null;
        let currentSectionCount = 1;

        // Test function to verify JS is working
        function testJS() {
            alert('JavaScript fonctionne !');
            console.log('‚úì JavaScript test successful');
        }

        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function hideStatus() {
            document.getElementById('status').style.display = 'none';
        }

        function parseTournamentData(data) {
            const pairs = [];
            const lines = data.split('\n');
            let currentPair = null;
            let pairNumber = 1;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();

                if (!line || line.includes('Inscription') || line.includes('Nouvelle √©quipe')) {
                    continue;
                }

                if (line.match(/^\d{2}\/\d{2}\/\d{4}/)) {
                    if (currentPair && currentPair.player1 && currentPair.player2) {
                        pairs.push(currentPair);
                    }
                    currentPair = { number: pairNumber++, player1: null, player2: null };
                    continue;
                }

                const playerMatch = line.match(/^(M\.|Mme)\s+(.+?)\s+\(\s*([\d.]+)\s*‚Ç¨\s*\)/);
                if (playerMatch) {
                    const fullName = playerMatch[2];
                    const amount = parseFloat(playerMatch[3]);

                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        const licenseMatch = nextLine.match(/(\d{8})\s*\(\s*IV\s*=\s*(\d+)\s*\)/);

                        if (licenseMatch) {
                            const license = licenseMatch[1];
                            const iv = parseInt(licenseMatch[2]);

                            const player = {
                                name: fullName,
                                license: license,
                                iv: iv,
                                amount: amount
                            };

                            if (!currentPair.player1) {
                                currentPair.player1 = player;
                            } else if (!currentPair.player2) {
                                currentPair.player2 = player;
                            }

                            i++;
                        }
                    }
                }
            }

            if (currentPair && currentPair.player1 && currentPair.player2) {
                pairs.push(currentPair);
            }

            return pairs;
        }

        function calculateCombinedIV(pair) {
            return (pair.player1?.iv || 0) + (pair.player2?.iv || 0);
        }

        let nsConstraints = new Set();
        let currentPage = 1;
        let totalPages = 1;
        let tablesPerPage = 10;
        let autoPageInterval = null;

        function mitchellDistribution(pairs, sectionCount, useConstraints = false) {
            console.log('üîç MITCHELL: Starting with', pairs.length, 'pairs,', sectionCount, 'sections');

            // Sort pairs by IV (t√™tes de s√©rie)
            const sortedPairs = [...pairs].sort((a, b) => calculateCombinedIV(b) - calculateCombinedIV(a));

            // Add pair IDs and constraint flags
            sortedPairs.forEach((pair, i) => {
                if (!pair.id) pair.id = `pair_${i}`;
                pair.combinedIV = calculateCombinedIV(pair);
                pair.nsConstraint = useConstraints && nsConstraints.has(pair.id);
            });

            // Calculate tables per section using Mitchell algorithm
            const totalPairs = pairs.length;
            const hasRelais = totalPairs % 2 === 1;
            const totalTables = hasRelais ? (totalPairs + 1) / 2 : totalPairs / 2;

            // Mitchell: distribute tables as evenly as possible
            const tablesPerSection = Math.ceil(totalTables / sectionCount);

            // Ensure we don't have more sections than tables
            if (sectionCount > totalTables) {
                console.warn('‚ö†Ô∏è MITCHELL: More sections than tables, adjusting...');
                sectionCount = Math.min(sectionCount, totalTables);
            }

            console.log('üîç MITCHELL: Total tables:', totalTables, 'Tables per section:', tablesPerSection);

            // Initialize sections with table numbers 1 to N in EACH section
            const sections = Array.from({ length: sectionCount }, (_, sectionIndex) => {
                return Array.from({ length: tablesPerSection }, (_, i) => ({
                    tableNumber: i + 1,  // Chaque section: 1, 2, 3, 4, 5...
                    ns: null,
                    eo: null
                }));
            });

            // Mitchell Algorithm Implementation
            try {
                console.log('üîç MITCHELL: Calling generateMitchellPlacement...');
                const result = generateMitchellPlacement(sections, sortedPairs, sectionCount, useConstraints);

                if (result !== true) {
                    console.error('‚ùå MITCHELL: generateMitchellPlacement failed');
                    throw new Error('Failed to generate Mitchell placement');
                }

                console.log('üîç DEBUG: Returning sections:', sections);
                console.log('üîç DEBUG: Sections length:', sections.length);
                return sections;

            } catch (error) {
                console.error('‚ùå MITCHELL: Error in mitchellDistribution:', error);
                // Fallback to simple distribution
                return generateSimpleFallback(sections, sortedPairs);
            }
        }

        function generateSimpleFallback(sections, sortedPairs) {
            console.log('üîÑ SIMPLE FALLBACK: Using basic distribution');
            let pairIndex = 0;

            // Simple distribution: place pairs sequentially
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                const section = sections[sectionIndex];

                for (let tableIndex = 0; tableIndex < section.length; tableIndex++) {
                    const table = section[tableIndex];

                    // Place NS pair
                    if (pairIndex < sortedPairs.length) {
                        table.ns = sortedPairs[pairIndex];
                        pairIndex++;
                    }

                    // Place EW pair
                    if (pairIndex < sortedPairs.length) {
                        table.eo = sortedPairs[pairIndex];
                        pairIndex++;
                    }
                }
            }

            console.log('‚úÖ SIMPLE FALLBACK: Distribution completed');
            return sections;
        }

        function generateMitchellPlacement(sections, sortedPairs, sectionCount, useConstraints) {
            console.log('üîç MITCHELL: Placing', sortedPairs.length, 'pairs with true Mitchell algorithm');

            // Si contraintes activ√©es, utiliser la gestion des contraintes
            if (useConstraints) {
                return applyMitchellConstraints(sections, sortedPairs, sectionCount);
            }

            // G√©n√©ration initiale : Vraie logique Mitchell selon les r√®gles d√©crites
            return generateTrueMitchellDistribution(sections, sortedPairs, sectionCount);
        }

        function generateTrueMitchellDistribution(sections, sortedPairs, sectionCount) {
            console.log('üîÑ TRUE MITCHELL: G√©n√©ration selon r√®gles Mitchell officielles');
            console.log('üîç Sections:', sectionCount, 'Paires:', sortedPairs.length);

            // Debug: Afficher les 10 premi√®res paires tri√©es
            console.log('üîç DEBUG: Top 10 paires tri√©es:');
            for (let i = 0; i < Math.min(10, sortedPairs.length); i++) {
                const pair = sortedPairs[i];
                console.log(`  ${i+1}. ${pair.player1?.name}/${pair.player2?.name} (IV: ${pair.combinedIV})`);
            }

            // Calculer le nombre total de tables
            const hasRelais = sortedPairs.length % 2 === 1;
            const totalTables = Math.ceil(sortedPairs.length / 2);

            console.log('üîç Total tables:', totalTables, 'Relais:', hasRelais);

            // Initialiser toutes les positions √† null
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < sections[sectionIndex].length; tableIndex++) {
                    sections[sectionIndex][tableIndex].ns = null;
                    sections[sectionIndex][tableIndex].eo = null;
                }
            }

            let pairIndex = 0;

            // G√©n√©rer la s√©quence compl√®te des tables Mitchell (saut de 3)
            const mitchellSequence = generateMitchellSequence(totalTables);
            console.log('üîç Mitchell sequence:', mitchellSequence.join(','));

            // Parcourir toutes les tables dans l'ordre Mitchell
            for (let i = 0; i < mitchellSequence.length && pairIndex < sortedPairs.length; i++) {
                const currentTable = mitchellSequence[i];

                // Trouver la section et table correspondante au num√©ro de table actuel
                const {sectionIndex, tableIndex} = findTablePosition(sections, currentTable);

                if (sectionIndex !== -1 && tableIndex !== -1) {
                    const table = sections[sectionIndex][tableIndex];

                    if (sectionCount === 1) {
                        // 1 section: NS puis EO altern√©s sur m√™me table
                        if (!table.ns && pairIndex < sortedPairs.length) {
                            table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable} NS: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        if (!table.eo && pairIndex < sortedPairs.length) {
                            table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable} EO: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                    } else if (sectionCount === 2) {
                        // 2 sections: NS A, NS B, EO B, EO A (serpentin sur toutes les sections)
                        const allTablesForThisNumber = findAllTablesWithNumber(sections, currentTable);

                        // Assurer l'ordre A, B pour les sections
                        allTablesForThisNumber.sort((a, b) => a.sectionIndex - b.sectionIndex);

                        // Placer NS A
                        if (allTablesForThisNumber[0] && !allTablesForThisNumber[0].table.ns && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[0].table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}A NS: Paire ${pairIndex+1} ${sortedPairs[pairIndex].player1?.name}/${sortedPairs[pairIndex].player2?.name} (IV: ${sortedPairs[pairIndex].combinedIV})`);
                            pairIndex++;
                        }
                        // Placer NS B
                        if (allTablesForThisNumber[1] && !allTablesForThisNumber[1].table.ns && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[1].table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}B NS: Paire ${pairIndex+1} ${sortedPairs[pairIndex].player1?.name}/${sortedPairs[pairIndex].player2?.name} (IV: ${sortedPairs[pairIndex].combinedIV})`);
                            pairIndex++;
                        }
                        // Placer EO B
                        if (allTablesForThisNumber[1] && !allTablesForThisNumber[1].table.eo && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[1].table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}B EO: Paire ${pairIndex+1} ${sortedPairs[pairIndex].player1?.name}/${sortedPairs[pairIndex].player2?.name} (IV: ${sortedPairs[pairIndex].combinedIV})`);
                            pairIndex++;
                        }
                        // Placer EO A
                        if (allTablesForThisNumber[0] && !allTablesForThisNumber[0].table.eo && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[0].table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}A EO: Paire ${pairIndex+1} ${sortedPairs[pairIndex].player1?.name}/${sortedPairs[pairIndex].player2?.name} (IV: ${sortedPairs[pairIndex].combinedIV})`);
                            pairIndex++;
                        }
                    } else if (sectionCount === 3) {
                        // 3 sections: NS A, NS B, NS C, EO C, EO B, EO A (serpentin sur toutes les sections)
                        const allTablesForThisNumber = findAllTablesWithNumber(sections, currentTable);

                        // Assurer l'ordre A, B, C pour les sections
                        allTablesForThisNumber.sort((a, b) => a.sectionIndex - b.sectionIndex);

                        // Placer NS A
                        if (allTablesForThisNumber[0] && !allTablesForThisNumber[0].table.ns && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[0].table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}A NS: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        // Placer NS B
                        if (allTablesForThisNumber[1] && !allTablesForThisNumber[1].table.ns && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[1].table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}B NS: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        // Placer NS C
                        if (allTablesForThisNumber[2] && !allTablesForThisNumber[2].table.ns && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[2].table.ns = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}C NS: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        // Placer EO C
                        if (allTablesForThisNumber[2] && !allTablesForThisNumber[2].table.eo && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[2].table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}C EO: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        // Placer EO B
                        if (allTablesForThisNumber[1] && !allTablesForThisNumber[1].table.eo && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[1].table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}B EO: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                        // Placer EO A
                        if (allTablesForThisNumber[0] && !allTablesForThisNumber[0].table.eo && pairIndex < sortedPairs.length) {
                            allTablesForThisNumber[0].table.eo = sortedPairs[pairIndex];
                            console.log(`üîç T${currentTable}A EO: ${sortedPairs[pairIndex].player1?.name}`);
                            pairIndex++;
                        }
                    }
                }
            }

            console.log('‚úÖ TRUE MITCHELL: Distribution termin√©e');
            return true;
        }

        function generateMitchellSequence(totalTables) {
            // G√©n√©rer la s√©quence Mitchell : 1,4,7,10... puis 2,5,8,11... puis 3,6,9,12...
            const sequence = [];

            for (let series = 1; series <= 3; series++) {
                for (let table = series; table <= totalTables; table += 3) {
                    sequence.push(table);
                }
            }

            return sequence;
        }

        function findTablePosition(sections, tableNumber) {
            // Trouver la section et l'index de table correspondant √† un num√©ro de table
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < sections[sectionIndex].length; tableIndex++) {
                    if (sections[sectionIndex][tableIndex].tableNumber === tableNumber) {
                        return {sectionIndex, tableIndex};
                    }
                }
            }
            return {sectionIndex: -1, tableIndex: -1};
        }

        function findTableInOtherSection(sections, tableNumber, currentSectionIndex) {
            // Trouver la table avec le m√™me num√©ro dans une autre section
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                if (sectionIndex !== currentSectionIndex) {
                    for (let tableIndex = 0; tableIndex < sections[sectionIndex].length; tableIndex++) {
                        if (sections[sectionIndex][tableIndex].tableNumber === tableNumber) {
                            return sections[sectionIndex][tableIndex];
                        }
                    }
                }
            }
            return null;
        }

        function findAllTablesWithNumber(sections, tableNumber) {
            // Trouver toutes les tables avec le m√™me num√©ro dans toutes les sections
            const tables = [];
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < sections[sectionIndex].length; tableIndex++) {
                    if (sections[sectionIndex][tableIndex].tableNumber === tableNumber) {
                        tables.push({
                            sectionIndex,
                            tableIndex,
                            table: sections[sectionIndex][tableIndex]
                        });
                    }
                }
            }
            return tables;
        }

        function getNextMitchellTable(currentTable, totalTables) {
            // Logique de saut de 3 tables Mitchell: 1,4,7,10... puis 2,5,8,11... puis 3,6,9,12...
            let nextTable = currentTable + 3;

            if (nextTable > totalTables) {
                // Si on d√©passe, passer √† la s√©rie suivante
                const currentSeries = ((currentTable - 1) % 3) + 1; // 1, 2, ou 3
                const nextSeries = (currentSeries % 3) + 1;

                // Prendre directement la premi√®re table de la s√©rie suivante
                nextTable = nextSeries;

                // Si la s√©rie suivante d√©passe aussi, on a termin√©
                if (nextTable > totalTables) {
                    return null; // Plus de tables
                }
            }

            console.log(`üîç Mitchell table sequence: ${currentTable} ‚Üí ${nextTable} (total: ${totalTables})`);
            return nextTable;
        }

        function applyMitchellConstraints(sections, sortedPairs, sectionCount) {
            console.log('üîí CONTRAINTES MITCHELL: Application des contraintes NS avec m√©morisation EO');

            // Calculer le nombre total de tables
            const hasRelais = sortedPairs.length % 2 === 1;
            const totalTables = Math.ceil(sortedPairs.length / 2);

            // Initialiser toutes les positions √† null
            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < sections[sectionIndex].length; tableIndex++) {
                    sections[sectionIndex][tableIndex].ns = null;
                    sections[sectionIndex][tableIndex].eo = null;
                }
            }

            let pairIndex = 0;
            let memorizedEOPair = null; // M√©moire pour paire EO d√©plac√©e

            // G√©n√©rer la s√©quence Mitchell
            const mitchellSequence = generateMitchellSequence(totalTables);
            console.log('üîç Mitchell sequence with constraints:', mitchellSequence.join(','));

            // Parcourir toutes les tables dans l'ordre Mitchell
            for (let i = 0; i < mitchellSequence.length && pairIndex < sortedPairs.length; i++) {
                const currentTable = mitchellSequence[i];
                const {sectionIndex, tableIndex} = findTablePosition(sections, currentTable);

                if (sectionIndex !== -1 && tableIndex !== -1) {
                    const table = sections[sectionIndex][tableIndex];

                    if (sectionCount === 1) {
                        // 1 section avec contraintes
                        // Placer NS (avec gestion contraintes)
                        if (!table.ns && pairIndex < sortedPairs.length) {
                            const currentPair = sortedPairs[pairIndex];

                            // Si paire m√©moris√©e en attente et position NS disponible
                            if (memorizedEOPair) {
                                table.ns = memorizedEOPair;
                                memorizedEOPair = null;
                                console.log(`üîç T${currentTable} NS: ${table.ns.player1?.name} (r√©cup√©r√©e de m√©moire)`);
                            } else {
                                table.ns = currentPair;
                                pairIndex++;
                                console.log(`üîç T${currentTable} NS: ${currentPair.player1?.name} ${currentPair.nsConstraint ? '(NS FIXE)' : ''}`);
                            }
                        }

                        // Placer EO (avec gestion contraintes)
                        if (!table.eo && pairIndex < sortedPairs.length) {
                            const currentPair = sortedPairs[pairIndex];

                            // Si la paire suivante a une contrainte NS fixe
                            if (currentPair.nsConstraint) {
                                // M√©moriser la paire actuelle pour plus tard et passer √† la suivante
                                if (memorizedEOPair) {
                                    // S'il y a d√©j√† une paire m√©moris√©e, la placer
                                    table.eo = memorizedEOPair;
                                    memorizedEOPair = currentPair;
                                    console.log(`üîç T${currentTable} EO: ${table.eo.player1?.name} (m√©moris√©e pr√©c√©demment)`);
                                } else {
                                    memorizedEOPair = currentPair;
                                    console.log(`üîí Paire ${currentPair.player1?.name} m√©moris√©e (NS fixe)`);
                                }
                                pairIndex++;

                                // Essayer la paire suivante pour EO
                                if (pairIndex < sortedPairs.length && !sortedPairs[pairIndex].nsConstraint) {
                                    table.eo = sortedPairs[pairIndex];
                                    pairIndex++;
                                    console.log(`üîç T${currentTable} EO: ${table.eo.player1?.name}`);
                                }
                            } else {
                                table.eo = currentPair;
                                pairIndex++;
                                console.log(`üîç T${currentTable} EO: ${currentPair.player1?.name}`);
                            }
                        }
                    }
                    // TODO: Impl√©menter pour 2 et 3 sections si besoin
                }
            }

            console.log('‚úÖ CONTRAINTES MITCHELL: Distribution avec contraintes termin√©e');
            return true;
        }

        function generateMitchellPlacementFallback(sections, sortedPairs, sectionCount) {
            console.log('üîÑ MITCHELL FALLBACK: Using traditional Mitchell placement');

            // Step 1: Handle NS constraints first (fixed positioning)
            const constraintPairs = [];
            const regularPairs = [];

            sortedPairs.forEach(pair => {
                if (pair.nsConstraint) {
                    constraintPairs.push(pair);
                } else {
                    regularPairs.push(pair);
                }
            });

            console.log('üîç MITCHELL FALLBACK: Constraint pairs:', constraintPairs.length, 'Regular pairs:', regularPairs.length);

            // Step 2: Place constraint pairs in optimal NS positions (√©quilibrage)
            constraintPairs.forEach(pair => {
                const bestNSPosition = findBestNSPositionForEquilibrage(sections, pair, sectionCount);
                if (bestNSPosition) {
                    sections[bestNSPosition.section][bestNSPosition.table].ns = pair;
                    console.log('üîí MITCHELL FALLBACK: Placed constraint pair optimally at section', bestNSPosition.section, 'table', bestNSPosition.table + 1);
                }
            });

            // Step 3: Mitchell placement for remaining pairs
            // NS fixes par table : table i re√ßoit paire i en NS (si libre)
            // EO mobiles : ordre croissant des indices
            let pairIndex = 0;

            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                const section = sections[sectionIndex];

                for (let tableIndex = 0; tableIndex < section.length; tableIndex++) {
                    const table = section[tableIndex];

                    // Place NS if not already occupied by constraint
                    if (!table.ns && pairIndex < regularPairs.length) {
                        table.ns = regularPairs[pairIndex];
                        pairIndex++;
                    }

                    // Place EO (mobile pairs)
                    if (!table.eo && pairIndex < regularPairs.length) {
                        table.eo = regularPairs[pairIndex];
                        pairIndex++;
                    }
                }
            }

            // Handle any remaining pairs (edge case)
            while (pairIndex < regularPairs.length) {
                const placed = placeInNextAvailable(sections, regularPairs[pairIndex], sectionCount);
                if (!placed) break;
                pairIndex++;
            }

            console.log('üîç MITCHELL: Placement completed');
            return sections;
        }

        function equilibrageMitchellMultiSections(pairesNS, pairesEW, nbSections = 1, targetEcart = 20) {
            /**
             * Algorithme √©quilibrage Mitchell pour 1-3 sections (A/B/C).
             * - Divise paires en sections √©gales (ou quasi).
             * - √âquilibre chaque section ind√©pendamment.
             * - Option : √©quilibrage global entre sections pour simultan√©s.
             */
            console.log('üéØ EQUILIBRAGE MULTI-SECTIONS: Starting with', pairesNS.length, 'NS pairs and', pairesEW.length, 'EW pairs');

            // Validation des donn√©es d'entr√©e
            if (!pairesNS || !pairesEW || pairesNS.length === 0 || pairesEW.length === 0) {
                throw new Error('Donn√©es d\'entr√©e invalides pour l\'√©quilibrage');
            }

            if (nbSections < 1 || nbSections > 3) {
                throw new Error('Nombre de sections invalide (doit √™tre entre 1 et 3)');
            }

            function forceMoyenne(paire) {
                if (!paire) return 100;
                return paire.force || paire.combinedIV || (paire.iv || 100); // Utilise la force, combinedIV ou IV par d√©faut
            }

            const forcesNS = pairesNS.map(forceMoyenne);
            const forcesEW = pairesEW.map(forceMoyenne);
            const totalPairesNS = pairesNS.length;
            const lignesParSection = Math.floor(totalPairesNS / nbSections);

            if (totalPairesNS % nbSections !== 0) {
                console.warn('‚ö†Ô∏è EQUILIBRAGE: Nombre de paires NS non divisible par nb_sections');
            }

            // Diviser en sections (tri fort/faible altern√© pour fair-play)
            const nsTrieIdx = Array.from({length: totalPairesNS}, (_, i) => i)
                .sort((a, b) => forcesNS[b] - forcesNS[a]); // Plus fort vers plus faible

            const sectionsNSIdx = [];
            for (let i = 0; i < nbSections; i++) {
                sectionsNSIdx.push([]);
                for (let j = i; j < nsTrieIdx.length; j += nbSections) {
                    if (sectionsNSIdx[i].length < lignesParSection) {
                        sectionsNSIdx[i].push(nsTrieIdx[j]);
                    }
                }
            }

            const sectionsEWIdx = [];
            const resultatsSection = [];

            for (let sec = 0; sec < nbSections; sec++) {
                const secNSIdx = sectionsNSIdx[sec];
                const secNS = secNSIdx.map(i => pairesNS[i]);
                const secForcesNS = secNSIdx.map(i => forcesNS[i]);

                // Candidats EW : reste apr√®s assignations pr√©c√©dentes
                const ewDispoIdx = [];
                for (let i = 0; i < pairesEW.length; i++) {
                    const dejaAssigne = sectionsEWIdx.some(section => section.includes(i));
                    if (!dejaAssigne) {
                        ewDispoIdx.push(i);
                    }
                }

                const secForcesEW = ewDispoIdx.map(i => forcesEW[i]);

                // Optimiser assign EW pour cette section
                const totalSecNS = secForcesNS.reduce((a, b) => a + b, 0);

                // Optimisation simplifi√©e : assignment direct avec tri par force
                const indices = Array.from({length: Math.min(secForcesEW.length, lignesParSection)}, (_, i) => i);

                // Trier les indices EW par force pour un assignment optimal simple (plus fort vers plus faible)
                indices.sort((a, b) => secForcesEW[b] - secForcesEW[a]);

                // Assignment direct des premiers lignesParSection
                const meilleurAssign = indices.slice(0, lignesParSection);
                const totalPerm = meilleurAssign.reduce((sum, i) => sum + secForcesEW[i], 0);
                const meilleurEcart = Math.abs(totalSecNS - totalPerm);

                console.log('üéØ EQUILIBRAGE: Section', sec, '√©cart:', meilleurEcart.toFixed(1));

                const secEWIdx = meilleurAssign ? meilleurAssign.map(i => ewDispoIdx[i]) : [];
                sectionsEWIdx.push(secEWIdx);

                // √âcarts lignes
                const ecartsLignes = [];
                if (meilleurAssign && meilleurAssign.length > 0) {
                    for (let j = 0; j < lignesParSection && j < secForcesNS.length && j < meilleurAssign.length; j++) {
                        const ecartLigne = Math.abs(secForcesNS[j] - secForcesEW[meilleurAssign[j]]);
                        ecartsLignes.push(ecartLigne);
                    }
                }

                const lignesNS = [];
                for (let j = 0; j < Math.min(lignesParSection, secNS.length, secEWIdx.length); j++) {
                    lignesNS.push([secNS[j], pairesEW[secEWIdx[j]]]);
                }

                resultatsSection.push({
                    section: String.fromCharCode(65 + sec), // A, B, C
                    lignesNS: lignesNS,
                    ecartTotal: meilleurEcart,
                    ecartsLignes: ecartsLignes
                });
            }

            // √âquilibrage global optionnel (moyennes sections)
            const moyennesSection = resultatsSection.map(res => {
                const sommeForces = res.lignesNS.reduce((sum, ligne) => sum + forceMoyenne(ligne[0]), 0);
                return sommeForces / res.lignesNS.length;
            });

            const ecartGlobalSections = Math.max(...moyennesSection) - Math.min(...moyennesSection);

            console.log('üéØ EQUILIBRAGE: Sections g√©n√©r√©es avec √©cart global:', ecartGlobalSections);

            // Optimisation suppl√©mentaire d√©sactiv√©e pour √©viter le moulinement
            // if (ecartGlobalSections > targetEcart && nbSections > 1) {
            //     console.log('‚ö†Ô∏è EQUILIBRAGE: √âcart global trop important, tentative d\'optimisation inter-sections');
            //     const optimisedResult = optimiseEquilibrageGlobal(resultatsSection, pairesNS, pairesEW, targetEcart);
            //     if (optimisedResult) {
            //         return optimisedResult;
            //     }
            // }

            return {
                sections: resultatsSection,
                ecartGlobalSections: ecartGlobalSections,
                moyennesSection: moyennesSection
            };
        }

        function optimiseEquilibrageGlobal(resultatsSection, pairesNS, pairesEW, targetEcart) {
            /**
             * Optimise l'√©quilibrage global en √©changeant des paires entre sections
             * pour r√©duire l'√©cart de moyennes entre les sections
             */
            console.log('üîÑ OPTIMISATION: Tentative d\'am√©lioration de l\'√©quilibrage inter-sections');

            function forceMoyenne(paire) {
                return paire.force || (paire.iv || 100);
            }

            const sections = [...resultatsSection]; // Copie pour manipulation
            const maxIterations = 10;
            let iteration = 0;
            let meilleurEcart = Infinity;

            // Calculer l'√©cart initial
            const moyennesInitiales = sections.map(section => {
                const sommeForces = section.lignesNS.reduce((sum, ligne) => sum + forceMoyenne(ligne[0]), 0);
                return sommeForces / section.lignesNS.length;
            });
            meilleurEcart = Math.max(...moyennesInitiales) - Math.min(...moyennesInitiales);

            console.log('üîÑ OPTIMISATION: √âcart initial:', meilleurEcart, 'Moyennes:', moyennesInitiales);

            while (iteration < maxIterations && meilleurEcart > targetEcart) {
                // Identifier la section la plus forte et la plus faible
                const moyennes = sections.map(section => {
                    const sommeForces = section.lignesNS.reduce((sum, ligne) => sum + forceMoyenne(ligne[0]), 0);
                    return sommeForces / section.lignesNS.length;
                });

                const indexSectionForte = moyennes.indexOf(Math.max(...moyennes));
                const indexSectionFaible = moyennes.indexOf(Math.min(...moyennes));

                if (indexSectionForte === indexSectionFaible) {
                    break; // √âquilibrage parfait atteint
                }

                // Trouver les meilleures paires √† √©changer
                const sectionForte = sections[indexSectionForte];
                const sectionFaible = sections[indexSectionFaible];

                let meilleurEchange = null;
                let meilleurGain = 0;

                // Tester tous les √©changes possibles de paires NS
                for (let i = 0; i < sectionForte.lignesNS.length; i++) {
                    for (let j = 0; j < sectionFaible.lignesNS.length; j++) {
                        const paireForteDeLaSectionForte = sectionForte.lignesNS[i][0];
                        const paireFaibleDeLaSectionFaible = sectionFaible.lignesNS[j][0];

                        const forceForte = forceMoyenne(paireForteDeLaSectionForte);
                        const forceFaible = forceMoyenne(paireFaibleDeLaSectionFaible);

                        if (forceForte > forceFaible) {
                            // Calculer le gain potentiel de l'√©change
                            const gain = (forceForte - forceFaible) / 2; // Gain approximatif
                            if (gain > meilleurGain) {
                                meilleurGain = gain;
                                meilleurEchange = {
                                    sectionForte: indexSectionForte,
                                    tableForte: i,
                                    sectionFaible: indexSectionFaible,
                                    tableFaible: j
                                };
                            }
                        }
                    }
                }

                if (meilleurEchange && meilleurGain > 0.5) {
                    // Effectuer l'√©change
                    const tempPaireNS = sections[meilleurEchange.sectionForte].lignesNS[meilleurEchange.tableForte][0];
                    sections[meilleurEchange.sectionForte].lignesNS[meilleurEchange.tableForte][0] =
                        sections[meilleurEchange.sectionFaible].lignesNS[meilleurEchange.tableFaible][0];
                    sections[meilleurEchange.sectionFaible].lignesNS[meilleurEchange.tableFaible][0] = tempPaireNS;

                    // Recalculer l'√©cart
                    const nouvellesMoyennes = sections.map(section => {
                        const sommeForces = section.lignesNS.reduce((sum, ligne) => sum + forceMoyenne(ligne[0]), 0);
                        return sommeForces / section.lignesNS.length;
                    });
                    const nouvelEcart = Math.max(...nouvellesMoyennes) - Math.min(...nouvellesMoyennes);

                    console.log('üîÑ OPTIMISATION: √âchange effectu√©, nouvel √©cart:', nouvelEcart);

                    if (nouvelEcart < meilleurEcart) {
                        meilleurEcart = nouvelEcart;
                    } else {
                        // Annuler l'√©change si pas d'am√©lioration
                        const tempPaireNS2 = sections[meilleurEchange.sectionForte].lignesNS[meilleurEchange.tableForte][0];
                        sections[meilleurEchange.sectionForte].lignesNS[meilleurEchange.tableForte][0] =
                            sections[meilleurEchange.sectionFaible].lignesNS[meilleurEchange.tableFaible][0];
                        sections[meilleurEchange.sectionFaible].lignesNS[meilleurEchange.tableFaible][0] = tempPaireNS2;
                    }
                } else {
                    break; // Aucun √©change b√©n√©fique trouv√©
                }

                iteration++;
            }

            if (meilleurEcart < Math.max(...moyennesInitiales) - Math.min(...moyennesInitiales)) {
                console.log('‚úÖ OPTIMISATION: Am√©lioration r√©alis√©e, √©cart final:', meilleurEcart);

                // Recalculer les moyennes finales
                const moyennesFinales = sections.map(section => {
                    const sommeForces = section.lignesNS.reduce((sum, ligne) => sum + forceMoyenne(ligne[0]), 0);
                    return sommeForces / section.lignesNS.length;
                });

                return {
                    sections: sections,
                    ecartGlobalSections: meilleurEcart,
                    moyennesSection: moyennesFinales
                };
            }

            console.log('‚ùå OPTIMISATION: Aucune am√©lioration possible');
            return null;
        }

        function applyConstraintsToExistingPlacement(sections, sortedPairs, sectionCount) {
            console.log('üîí CONTRAINTES: Application des contraintes NS sur placement existant');

            // Identifier les paires avec contraintes NS et les autres
            const constraintPairs = sortedPairs.filter(pair => pair.nsConstraint);
            const nonConstraintPairs = sortedPairs.filter(pair => !pair.nsConstraint);

            console.log('üîí CONTRAINTES: Found', constraintPairs.length, 'constraint pairs,', nonConstraintPairs.length, 'free pairs');

            if (constraintPairs.length === 0) {
                console.log('üîí CONTRAINTES: No constraints to apply');
                return true;
            }

            // Cr√©er une nouvelle distribution en conservant l'√©quilibrage global
            // 1. Retirer toutes les paires des sections
            const allExistingPairs = [];
            for (let s = 0; s < sections.length; s++) {
                for (let t = 0; t < sections[s].length; t++) {
                    if (sections[s][t].ns) allExistingPairs.push(sections[s][t].ns);
                    if (sections[s][t].ew) allExistingPairs.push(sections[s][t].ew);
                    sections[s][t].ns = null;
                    sections[s][t].ew = null;
                }
            }

            // 2. Placer d'abord les contraintes NS aux meilleures positions
            const usedNSPositions = [];
            constraintPairs.forEach(pair => {
                const bestPosition = findBestNSPositionForEquilibrage(sections, pair, sectionCount, usedNSPositions);
                if (bestPosition) {
                    sections[bestPosition.section][bestPosition.table].ns = pair;
                    usedNSPositions.push({section: bestPosition.section, table: bestPosition.table});
                    console.log('üîí CONTRAINTES: Placed constraint pair at section', bestPosition.section, 'table', bestPosition.table + 1);
                }
            });

            // 3. Redistribuer les paires restantes en utilisant l'algorithme d'√©quilibrage
            const remainingPairs = allExistingPairs.filter(pair => !pair.nsConstraint);

            if (remainingPairs.length > 0) {
                try {
                    // Calculer les paires NS et EW restantes n√©cessaires
                    const availableNSPositions = [];
                    const availableEWPositions = [];

                    for (let s = 0; s < sections.length; s++) {
                        for (let t = 0; t < sections[s].length; t++) {
                            if (!sections[s][t].ns) {
                                availableNSPositions.push({section: s, table: t});
                            }
                            if (!sections[s][t].ew) {
                                availableEWPositions.push({section: s, table: t});
                            }
                        }
                    }

                    console.log('üîí CONTRAINTES: Available NS positions:', availableNSPositions.length, 'EW positions:', availableEWPositions.length);

                    // √âquilibrer les paires restantes avec l'algorithme multi-sections modifi√©
                    const pairesNSRestantes = remainingPairs.slice(0, availableNSPositions.length);
                    const pairesEWRestantes = remainingPairs.slice(availableNSPositions.length);

                    // Placer les paires NS restantes
                    pairesNSRestantes.forEach((pair, index) => {
                        if (index < availableNSPositions.length) {
                            const pos = availableNSPositions[index];
                            sections[pos.section][pos.table].ns = pair;
                        }
                    });

                    // Placer les paires EW restantes
                    pairesEWRestantes.forEach((pair, index) => {
                        if (index < availableEWPositions.length) {
                            const pos = availableEWPositions[index];
                            sections[pos.section][pos.table].ew = pair;
                        }
                    });

                    console.log('‚úÖ CONTRAINTES: Redistribution completed with constraints preserved');

                } catch (error) {
                    console.error('‚ùå CONTRAINTES: Error during redistribution:', error);
                    return false;
                }
            }

            return true;
        }

        function findBestNSPositionForEquilibrage(sections, pair, sectionCount, usedPositions = []) {
            // Find the NS position that maintains best equilibrage
            let bestPosition = null;
            let bestScore = -1;

            function isPositionUsed(sectionIndex, tableIndex) {
                return usedPositions.some(pos => pos.section === sectionIndex && pos.table === tableIndex);
            }

            for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex++) {
                const section = sections[sectionIndex];

                for (let tableIndex = 0; tableIndex < section.length; tableIndex++) {
                    const table = section[tableIndex];

                    // Position disponible si pas de paire NS ET pas dans les positions utilis√©es
                    if (!table.ns && !isPositionUsed(sectionIndex, tableIndex)) {
                        // Calculate equilibrage score for this position
                        const score = calculateEquilibrageScore(sections, sectionIndex, tableIndex, pair);

                        if (score > bestScore) {
                            bestScore = score;
                            bestPosition = { section: sectionIndex, table: tableIndex };
                        }
                    }
                }
            }

            console.log('üîç EQUILIBRAGE: Found best position for pair', pair.names, 'at score', bestScore, 'position', bestPosition);
            return bestPosition;
        }

        function calculateEquilibrageScore(sections, sectionIndex, tableIndex, pair) {
            // Simple equilibrage: prefer positions that balance section strengths
            const currentSectionStrength = calculateSectionStrength(sections[sectionIndex]);
            const pairStrength = pair.combinedIV;

            // Lower current strength = better position for strong pair
            return 1000 - currentSectionStrength - (tableIndex * 10); // Slight preference for lower tables
        }

        function calculateSectionStrength(section) {
            let totalStrength = 0;
            let pairCount = 0;

            section.forEach(table => {
                if (table.ns) {
                    totalStrength += table.ns.combinedIV;
                    pairCount++;
                }
                if (table.eo) {
                    totalStrength += table.eo.combinedIV;
                    pairCount++;
                }
            });

            return pairCount > 0 ? totalStrength / pairCount : 0;
        }

        function generateSerpentinePattern(sectionCount, tablesPerSection) {
            const pattern = [];
            let tableGroup = 0;

            while (pattern.length < 200) { // Safety limit
                const baseTable = tableGroup * 3; // Tables 1,4,7... or 2,5,8... etc.

                for (let offset = 0; offset < 3; offset++) {
                    const tableIndex = baseTable + offset;

                    // For each table, place in order: A NS, B NS, B EO, A EO (2 sections)
                    // For 3 sections: A NS, B NS, C NS, C EO, B EO, A EO
                    if (sectionCount === 2) {
                        pattern.push({ section: 0, table: tableIndex, position: 'ns' }); // A NS
                        pattern.push({ section: 1, table: tableIndex, position: 'ns' }); // B NS
                        pattern.push({ section: 1, table: tableIndex, position: 'eo' }); // B EO
                        pattern.push({ section: 0, table: tableIndex, position: 'eo' }); // A EO
                    } else if (sectionCount === 3) {
                        pattern.push({ section: 0, table: tableIndex, position: 'ns' }); // A NS
                        pattern.push({ section: 1, table: tableIndex, position: 'ns' }); // B NS
                        pattern.push({ section: 2, table: tableIndex, position: 'ns' }); // C NS
                        pattern.push({ section: 2, table: tableIndex, position: 'eo' }); // C EO
                        pattern.push({ section: 1, table: tableIndex, position: 'eo' }); // B EO
                        pattern.push({ section: 0, table: tableIndex, position: 'eo' }); // A EO
                    }
                }
                tableGroup++;

                if (tableGroup > tablesPerSection) break;
            }

            return pattern;
        }

        function generateSerpentinePatternWithConstraints(sectionCount, tablesPerSection, sections) {
            const pattern = [];
            let tableGroup = 0;

            while (pattern.length < 200) { // Safety limit
                const baseTable = tableGroup * 3; // Tables 1,4,7... or 2,5,8... etc.

                for (let offset = 0; offset < 3; offset++) {
                    const tableIndex = baseTable + offset;

                    // Check if positions are available before adding to pattern
                    if (sectionCount === 2) {
                        // A NS
                        if (!sections[0][tableIndex]?.ns) {
                            pattern.push({ section: 0, table: tableIndex, position: 'ns' });
                        }
                        // B NS
                        if (sections[1] && !sections[1][tableIndex]?.ns) {
                            pattern.push({ section: 1, table: tableIndex, position: 'ns' });
                        }
                        // B EO
                        if (sections[1] && !sections[1][tableIndex]?.eo) {
                            pattern.push({ section: 1, table: tableIndex, position: 'eo' });
                        }
                        // A EO
                        if (!sections[0][tableIndex]?.eo) {
                            pattern.push({ section: 0, table: tableIndex, position: 'eo' });
                        }
                    } else if (sectionCount === 3) {
                        // A NS
                        if (!sections[0][tableIndex]?.ns) {
                            pattern.push({ section: 0, table: tableIndex, position: 'ns' });
                        }
                        // B NS
                        if (sections[1] && !sections[1][tableIndex]?.ns) {
                            pattern.push({ section: 1, table: tableIndex, position: 'ns' });
                        }
                        // C NS
                        if (sections[2] && !sections[2][tableIndex]?.ns) {
                            pattern.push({ section: 2, table: tableIndex, position: 'ns' });
                        }
                        // C EO
                        if (sections[2] && !sections[2][tableIndex]?.eo) {
                            pattern.push({ section: 2, table: tableIndex, position: 'eo' });
                        }
                        // B EO
                        if (sections[1] && !sections[1][tableIndex]?.eo) {
                            pattern.push({ section: 1, table: tableIndex, position: 'eo' });
                        }
                        // A EO
                        if (!sections[0][tableIndex]?.eo) {
                            pattern.push({ section: 0, table: tableIndex, position: 'eo' });
                        }
                    }
                }
                tableGroup++;

                if (tableGroup > tablesPerSection) break;
            }

            return pattern;
        }

        function placeInNextAvailable(sections, pair, sectionCount) {
            // Find next available position
            for (let s = 0; s < sectionCount; s++) {
                for (let t = 0; t < sections[s].length; t++) {
                    if (!sections[s][t].ns) {
                        sections[s][t].ns = pair;
                        return;
                    } else if (!sections[s][t].eo) {
                        sections[s][t].eo = pair;
                        return;
                    }
                }
            }
        }

        function getNextAvailableNSTable(sections, sectionCount) {
            for (let s = 0; s < sectionCount; s++) {
                for (let t = 0; t < sections[s].length; t++) {
                    if (!sections[s][t].ns) {
                        return { section: s, table: t };
                    }
                }
            }
            return -1;
        }

        function redistributeWithConstraints() {
            // Force regeneration with current constraints
            if (parsedPairs && parsedPairs.length > 0) {
                // Update constraint status for all pairs
                parsedPairs.forEach((pair, index) => {
                    if (!pair.id) pair.id = `pair_${index}`;
                    pair.nsConstraint = nsConstraints.has(pair.id);
                });

                // Regenerate the distribution
                const useConstraints = nsConstraints.size > 0;
                mitchellData = mitchellDistribution(parsedPairs, currentSectionCount, useConstraints);
                renderMitchellDisplay();
            }

            hideConstraintControls();
        }

        function generateSections() {
            console.log('üîç DEBUG: generateSections() appel√©e');

            // V√©rifier que les √©l√©ments existent
            const tournamentDataEl = document.getElementById('tournamentData');
            const sectionCountEl = document.getElementById('sectionCount');
            const entryFeeEl = document.getElementById('entryFee');

            if (!tournamentDataEl) {
                console.error('‚ùå ERROR: Element tournamentData not found');
                alert('Erreur: Zone de texte des donn√©es non trouv√©e');
                return;
            }

            if (!sectionCountEl) {
                console.error('‚ùå ERROR: Element sectionCount not found');
                alert('Erreur: S√©lecteur de sections non trouv√©');
                return;
            }

            const data = tournamentDataEl.value.trim();
            currentSectionCount = parseInt(sectionCountEl.value);
            const entryFee = parseFloat(entryFeeEl.value) || 5.0;

            console.log('üîç DEBUG: Data length:', data.length);
            console.log('üîç DEBUG: Section count:', currentSectionCount);

            if (!data) {
                showStatus('Veuillez coller les donn√©es du tournoi.', 'error');
                return;
            }

            try {
                console.log('üîç DEBUG: Parsing tournament data...');
                parsedPairs = parseTournamentData(data);
                console.log('üîç DEBUG: Parsed pairs:', parsedPairs);

                // Validation robuste des donn√©es pars√©es
                if (!parsedPairs || parsedPairs.length === 0) {
                    showStatus('Aucune paire valide trouv√©e dans les donn√©es.', 'error');
                    return;
                }

                // V√©rifier que chaque paire a les champs requis
                for (let i = 0; i < parsedPairs.length; i++) {
                    const pair = parsedPairs[i];
                    if (!pair.player1 || !pair.player2 ||
                        !pair.player1.name || !pair.player2.name ||
                        typeof pair.player1.iv !== 'number' || typeof pair.player2.iv !== 'number') {
                        console.error('‚ùå ERROR: Invalid pair at index', i, pair);
                        showStatus(`Erreur: Paire ${i + 1} incompl√®te ou mal format√©e.`, 'error');
                        return;
                    }
                }

                showStatus(`${parsedPairs.length} paires trouv√©es et analys√©es.`, 'success');

                console.log('üîç DEBUG: Creating mitchell distribution...');
                // Add payment status to pairs
                parsedPairs.forEach(pair => {
                    const totalPaid = (pair.player1?.amount || 0) + (pair.player2?.amount || 0);
                    const expectedTotal = entryFee * 2;

                    if (totalPaid >= expectedTotal) {
                        pair.paymentStatus = 'full';
                    } else if (totalPaid > 0) {
                        pair.paymentStatus = 'partial';
                    } else {
                        pair.paymentStatus = 'none';
                    }
                    pair.totalPaid = totalPaid;
                    pair.expectedTotal = expectedTotal;
                });

                console.log('üîç DEBUG: Input parsedPairs:', parsedPairs);
                console.log('üîç DEBUG: Input currentSectionCount:', currentSectionCount);
                console.log('üîç DEBUG: Entry fee:', entryFee);
                mitchellData = mitchellDistribution(parsedPairs, currentSectionCount);
                console.log('üîç DEBUG: Mitchell data created:', mitchellData);
                console.log('üîç DEBUG: Mitchell data length:', mitchellData.length);
                if (mitchellData.length > 0) {
                    console.log('üîç DEBUG: First section tables:', mitchellData[0].length);
                    console.log('üîç DEBUG: Sample table:', mitchellData[0][0]);
                }

                // Generate simple summary for setup view
                let html = '<h4>R√©sum√© de la r√©partition:</h4>';
                mitchellData.forEach((section, index) => {
                    const sectionName = currentSectionCount === 1 ? 'Section Unique' : `Section ${index + 1}`;
                    html += `<p><strong>${sectionName}:</strong> ${section.length} tables</p>`;
                });

                document.getElementById('sectionsContainer').innerHTML = html;
                document.getElementById('results').style.display = 'block';

                const totalIV = parsedPairs.reduce((sum, pair) => sum + calculateCombinedIV(pair), 0);
                const avgIV = (totalIV / parsedPairs.length).toFixed(1);

                showStatus(
                    `Sections g√©n√©r√©es avec succ√®s! ${parsedPairs.length} paires r√©parties. IV moyen: ${avgIV}`,
                    'success'
                );

                // Auto-show Mitchell display after generation
                setTimeout(() => {
                    console.log('üîç DEBUG: Auto-showing Mitchell display...');
                    console.log('üîç DEBUG: mitchellData before display:', mitchellData);
                    showMitchellDisplay();
                }, 500);

            } catch (error) {
                console.error('‚ùå ERROR in generateSections:', error);
                showStatus('Erreur lors de l\'analyse des donn√©es. V√©rifiez le format.', 'error');
            }
        }

        function showMitchellDisplay() {
            console.log('üîç DEBUG: showMitchellDisplay called, mitchellData length:', mitchellData.length);

            if (mitchellData.length === 0) {
                console.error('‚ùå ERROR: No mitchell data available');
                showStatus('Veuillez d\'abord g√©n√©rer les sections.', 'error');
                return;
            }

            console.log('üîç DEBUG: Switching to Mitchell view...');
            document.getElementById('setupView').style.display = 'none';
            document.getElementById('mitchellView').style.display = 'block';

            const container = document.getElementById('mitchellContainer');
            container.className = currentSectionCount === 1 ? 'sections-grid single-section' : 'sections-grid';

            console.log('üîç DEBUG: Calling renderMitchellDisplay...');
            renderMitchellDisplay();
            initializeSectionControls();

            // Auto-enter fullscreen
            setTimeout(() => enterFullscreen(), 100);
        }

        function showSetupView() {
            document.getElementById('setupView').style.display = 'block';
            document.getElementById('mitchellView').style.display = 'none';
            // Reset all constraints when returning to config
            nsConstraints.clear();
            currentPage = 1;
            stopAutoPage();
        }

        function renderMitchellDisplay() {
            console.log('üîç DEBUG: renderMitchellDisplay() appel√©e');

            const container = document.getElementById('mitchellContainer');
            console.log('üîç DEBUG: Container element:', container);

            let html = '';

            // Update tournament title
            const today = new Date().toLocaleDateString('fr-FR');
            const totalPairs = parsedPairs.length;
            console.log('üîç DEBUG: Total pairs:', totalPairs);

            if (totalPairs === 0) {
                console.error('‚ùå ERROR: No parsed pairs available');
                return;
            }

            // Calculate global IV average for header (suppression des moyennes NS/EO)
            const totalIV = parsedPairs.reduce((sum, pair) => sum + calculateCombinedIV(pair), 0);
            const avgIV = (totalIV / parsedPairs.length).toFixed(1);

            document.getElementById('tournamentTitle').textContent =
                `Bon tournoi au BCNJ - ${today} - ${totalPairs} paires, IV moyen ${avgIV}`;

            // Calculate pagination for single section with many tables
            const tableCount = Math.ceil(totalPairs / 2);
            const availableHeight = window.innerHeight - 140;

            // Determine display mode for single section
            const useTwoColumns = currentSectionCount === 1 && tableCount > 10;
            const needsPagination = false; // Disable pagination - use CSS height management instead

            if (needsPagination) {
                tablesPerPage = 10; // Show 10 tables per page
                totalPages = Math.ceil(tableCount / tablesPerPage);
                document.getElementById('pageNavigation').style.display = 'block';
                // Stop auto-page when in constraint mode
                if (!document.getElementById('constraintControls').style.display ||
                    document.getElementById('constraintControls').style.display === 'none') {
                    startAutoPage();
                } else {
                    stopAutoPage();
                }
            } else {
                totalPages = 1;
                currentPage = 1;
                document.getElementById('pageNavigation').style.display = 'none';
                stopAutoPage();
            }

            const maxTableHeight = needsPagination ?
                Math.floor(availableHeight / tablesPerPage) - 4 :
                Math.floor(availableHeight / Math.min(tableCount, 12)) - 4;
            const positionHeight = Math.max(32, Math.min(50, maxTableHeight - 12));

            document.documentElement.style.setProperty('--position-height', `${positionHeight}px`);

            // Update layout classes
            const sectionsGrid = container;
            const mitchellView = document.getElementById('mitchellView');

            // Reset all classes
            mitchellView.classList.remove('single-section', 'two-columns');
            sectionsGrid.classList.remove('two-sections', 'three-sections');

            if (currentSectionCount === 1) {
                mitchellView.classList.add('single-section');
                if (useTwoColumns) {
                    mitchellView.classList.add('two-columns');
                }
            } else if (currentSectionCount === 2) {
                sectionsGrid.classList.add('two-sections');
            } else if (currentSectionCount === 3) {
                sectionsGrid.classList.add('three-sections');
            }

            mitchellData.forEach((section, sectionIndex) => {
                const sectionName = currentSectionCount === 1 ? 'Section A' :
                    `Section ${String.fromCharCode(65 + sectionIndex)}`; // A, B, C...

                // Always use the correct section class based on index (a, b, c)
                const sectionClass = `section-${String.fromCharCode(97 + sectionIndex)}`; // section-a, section-b, section-c

                // Calculate section statistics (exclude relais/null pairs)
                const nsPairs = section.filter(table => table.ns && table.ns.combinedIV).map(table => table.ns);
                const eoPairs = section.filter(table => table.eo && table.eo.combinedIV).map(table => table.eo);

                // Calculate averages only from valid pairs
                const nsAvgIV = nsPairs.length > 0 ?
                    (nsPairs.reduce((sum, pair) => sum + (pair.combinedIV || 0), 0) / nsPairs.length).toFixed(1) : '0';
                const eoAvgIV = eoPairs.length > 0 ?
                    (eoPairs.reduce((sum, pair) => sum + (pair.combinedIV || 0), 0) / eoPairs.length).toFixed(1) : '0';

                // Format du titre avec IV moyens harmonieusement r√©partis - ALWAYS show section banner
                const sectionLetter = currentSectionCount === 1 ? 'A' : String.fromCharCode(65 + sectionIndex);
                const tableCount = section.filter(t => t.ns || t.eo).length;

                // Table count control only for multi-section - vertical layout
                const tableCountControl = currentSectionCount > 1 ? `
                    <div class="table-count-control">
                        <button class="table-count-btn" onclick="adjustTableCount(${sectionIndex}, 1)" title="Plus de tables">‚ñ≤</button>
                        <div class="table-count-display">
                            <span class="table-count-value">${tableCount}</span>
                            <span class="table-icon">‚ô†‚ô•</span>
                        </div>
                        <button class="table-count-btn" onclick="adjustTableCount(${sectionIndex}, -1)" title="Moins de tables">‚ñº</button>
                    </div>
                ` : '';

                const sectionBanner =
                    `<div class="section-banner">
                        ${tableCountControl}
                        <div class="section-letter">${sectionLetter}</div>
                        <div class="section-stats">
                            <div class="section-stats-line"></div>
                            <div class="section-stats-line">NS</div>
                            <div class="section-stats-line">~${Math.round(parseFloat(nsAvgIV))}</div>
                            <div class="section-stats-line">EO</div>
                            <div class="section-stats-line">~${Math.round(parseFloat(eoAvgIV))}</div>
                        </div>
                     </div>`;

                html += `
                    <div class="section-container ${sectionClass}">
                        ${sectionBanner}
                        <div class="section-content">
                            <div class="tables-grid ${needsPagination ? 'paginated' : ''}">
                `;

                // Filter tables for current page if pagination is active
                let tablesToShow = section;
                if (needsPagination) {
                    const startIndex = (currentPage - 1) * tablesPerPage;
                    const endIndex = startIndex + tablesPerPage;
                    tablesToShow = section.slice(startIndex, endIndex);
                }

                // For multiple sections, filter out empty tables
                if (currentSectionCount > 1) {
                    tablesToShow = tablesToShow.filter(table => table.ns || table.eo);
                }

                // Handle two-column layout for single section
                if (currentSectionCount === 1 && useTwoColumns) {
                    const halfPoint = Math.ceil(tablesToShow.length / 2);
                    const leftTables = tablesToShow.slice(0, halfPoint);
                    const rightTables = tablesToShow.slice(halfPoint);

                    // Left column
                    html += '<div class="column-left">';
                    leftTables.forEach(table => {
                        html += `
                            <div class="table-card">
                                <div class="table-header">${table.tableNumber}</div>
                                <div class="table-positions">
                                    ${renderPosition(table.ns, 'ns', sectionIndex, table.tableNumber)}
                                    ${renderPosition(table.eo, 'eo', sectionIndex, table.tableNumber)}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';

                    // Right column
                    html += '<div class="column-right">';
                    rightTables.forEach(table => {
                        html += `
                            <div class="table-card">
                                <div class="table-header">${table.tableNumber}</div>
                                <div class="table-positions">
                                    ${renderPosition(table.ns, 'ns', sectionIndex, table.tableNumber)}
                                    ${renderPosition(table.eo, 'eo', sectionIndex, table.tableNumber)}
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    // Normal single column layout
                    tablesToShow.forEach(table => {
                        html += `
                            <div class="table-card">
                                <div class="table-header">${table.tableNumber}</div>
                                <div class="table-positions">
                                    ${renderPosition(table.ns, 'ns', sectionIndex, table.tableNumber)}
                                    ${renderPosition(table.eo, 'eo', sectionIndex, table.tableNumber)}
                                </div>
                            </div>
                        `;
                    });
                }

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            console.log('üîç DEBUG: Generated HTML length:', html.length);
            console.log('üîç DEBUG: First 500 chars of HTML:', html.substring(0, 500));

            if (container) {
                container.innerHTML = html;
                console.log('üîç DEBUG: Container innerHTML set');
                console.log('üîç DEBUG: Container children count:', container.children.length);
            } else {
                console.error('‚ùå ERROR: Container not found!');
                return;
            }

            updatePageIndicator();
            initializeDragAndDrop();
            initializeConstraintSystem();

            // Restore dark mode if it was active
            setTimeout(() => {
                if (isDarkMode) {
                    console.log('üåô Restoring dark mode after render');
                    const body = document.body;
                    body.style.cssText = 'background-color: #1a1a1a !important; color: #e0e0e0 !important;';
                    body.className = 'dark-mode';
                }
            }, 100);
        }

        function renderPosition(pair, position, sectionIndex, tableNumber) {
            const entryFee = parseFloat(document.getElementById('entryFee')?.value) || 5.0;
            const positionClass = position === 'ns' ? 'ns-position' : 'eo-position';
            const positionId = `pos_${sectionIndex}_${tableNumber}_${position}`;

            if (!pair) {
                // Check if this should be RELAIS position
                const isRelais = position === 'eo' &&
                    mitchellData[sectionIndex] &&
                    tableNumber === mitchellData[sectionIndex].length &&
                    parsedPairs.length % 2 === 1;

                const relaisClass = isRelais ? 'relais-position' : '';
                const displayText = isRelais ? 'RELAIS' : 'Position libre';

                return `
                    <div class="position ${positionClass} ${relaisClass}" data-position="${positionId}" data-section="${sectionIndex}" data-table="${tableNumber}" data-pos="${position}">
                        <div class="empty-position">${displayText}</div>
                    </div>
                `;
            }

            // Convert FFB names to INITIAL. NOM format
            // FFB format: "NOM Pr√©nom" -> output: "P. NOM"
            // Examples: MARTIN Pierre -> P. MARTIN | DUPONT Jean-Claude -> J-C. DUPONT
            function formatNameToInitial(fullName) {
                if (!fullName || fullName === 'N/A') return 'N/A';
                const parts = fullName.trim().split(' ').filter(p => p.length > 0);
                if (parts.length === 0) return 'N/A';
                if (parts.length === 1) return parts[0].toUpperCase() + '.';

                // FFB format: first part is LASTNAME, rest is firstname(s)
                const lastName = parts[0].toUpperCase();
                const firstNameParts = parts.slice(1);

                // Handle hyphenated first names or multiple first names
                let initials = '';
                for (let i = 0; i < firstNameParts.length; i++) {
                    const namePart = firstNameParts[i];
                    if (namePart.includes('-')) {
                        // Hyphenated name like "Jean-Claude" -> "J-C"
                        const hyphenatedParts = namePart.split('-');
                        initials += hyphenatedParts.map(part => part.charAt(0).toUpperCase()).join('-');
                    } else {
                        // Regular name -> initial
                        initials += namePart.charAt(0).toUpperCase();
                        if (i < firstNameParts.length - 1) initials += '-';
                    }
                }

                return `${initials}. ${lastName}`;
            }

            const name1 = formatNameToInitial(pair.player1?.name);
            const name2 = formatNameToInitial(pair.player2?.name);

            const amount1 = pair.player1?.amount || 0;
            const amount2 = pair.player2?.amount || 0;

            const constraintClass = nsConstraints.has(pair.id) ? 'ns-constraint' : '';
            const paymentClass = `payment-${pair.paymentStatus || 'full'}`;

            return `
                <div class="position ${positionClass} ${constraintClass} ${paymentClass} clickable"
                     data-position="${positionId}"
                     data-section="${sectionIndex}"
                     data-table="${tableNumber}"
                     data-pos="${position}"
                     data-pair-id="${pair.id}"
                     data-iv="IV: ${pair.combinedIV}"
                     onclick="toggleCardDetails(this, event); toggleNSConstraint('${pair.id}')">
                    <div class="pair-info">
                        <div class="position-indicator">
                            <div class="${position}-text">${position.toUpperCase()}</div>
                        </div>
                        <div class="constraint-indicator">
                            <div class="lock-icon">üîí</div>
                            <div class="ns-text">NS</div>
                        </div>
                        <div class="player-names">
                            <div class="player-name ${name1.length > 15 ? (name1.length > 20 ? 'name-very-long' : 'name-long') : ''}">
                                <span>${name1}</span>
                                <span class="player-amount">${amount1.toFixed(2)}‚Ç¨</span>
                                ${amount1 < (entryFee || 5.0) ? `<span class="payment-info">‚ö†Ô∏è Manque ${((entryFee || 5.0) - amount1).toFixed(2)}‚Ç¨</span>` : ''}
                            </div>
                            <div class="player-name ${name2.length > 15 ? (name2.length > 20 ? 'name-very-long' : 'name-long') : ''}">
                                <span>${name2}</span>
                                <span class="player-amount">${amount2.toFixed(2)}‚Ç¨</span>
                                ${amount2 < (entryFee || 5.0) ? `<span class="payment-info">‚ö†Ô∏è Manque ${((entryFee || 5.0) - amount2).toFixed(2)}‚Ç¨</span>` : ''}
                            </div>
                        </div>
                        <div class="iv-total">IV: ${pair.combinedIV}</div>
                    </div>
                </div>
            `;
        }

        function initializeDragAndDrop() {
            const positions = document.querySelectorAll('.position');

            positions.forEach(position => {
                position.draggable = true;

                position.addEventListener('dragstart', function(e) {
                    const pairId = this.dataset.pairId;
                    if (pairId) {
                        draggedPair = findPairById(pairId);
                        this.classList.add('dragging');
                        highlightSimilarIVPositions(draggedPair.combinedIV);
                        e.dataTransfer.setData('text/plain', pairId);
                    } else {
                        e.preventDefault();
                    }
                });

                position.addEventListener('dragend', function(e) {
                    this.classList.remove('dragging');
                    clearIVHighlights();
                    draggedPair = null;
                });

                position.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drop-target');
                });

                position.addEventListener('dragleave', function(e) {
                    this.classList.remove('drop-target');
                });

                position.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.classList.remove('drop-target');

                    const pairId = e.dataTransfer.getData('text/plain');
                    if (pairId && draggedPair) {
                        handlePairDrop(draggedPair, this);
                    }
                });
            });
        }

        function findPairById(pairId) {
            for (let sectionIndex = 0; sectionIndex < mitchellData.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < mitchellData[sectionIndex].length; tableIndex++) {
                    const table = mitchellData[sectionIndex][tableIndex];
                    if (table.ns && table.ns.id === pairId) return table.ns;
                    if (table.eo && table.eo.id === pairId) return table.eo;
                }
            }
            return null;
        }

        function handlePairDrop(pair, targetPosition) {
            const targetSection = parseInt(targetPosition.dataset.section);
            const targetTable = parseInt(targetPosition.dataset.table);
            const targetPos = targetPosition.dataset.pos;

            // Find and remove pair from current position
            for (let sectionIndex = 0; sectionIndex < mitchellData.length; sectionIndex++) {
                for (let tableIndex = 0; tableIndex < mitchellData[sectionIndex].length; tableIndex++) {
                    const table = mitchellData[sectionIndex][tableIndex];
                    if (table.ns && table.ns.id === pair.id) table.ns = null;
                    if (table.eo && table.eo.id === pair.id) table.eo = null;
                }
            }

            // Move existing pair if target position is occupied
            const targetTableData = mitchellData[targetSection][targetTable - 1];
            const existingPair = targetTableData[targetPos];

            if (existingPair) {
                // Find first empty position for the displaced pair
                let placed = false;
                for (let sectionIndex = 0; sectionIndex < mitchellData.length && !placed; sectionIndex++) {
                    for (let tableIndex = 0; tableIndex < mitchellData[sectionIndex].length && !placed; tableIndex++) {
                        const table = mitchellData[sectionIndex][tableIndex];
                        if (!table.ns) {
                            table.ns = existingPair;
                            placed = true;
                        } else if (!table.eo) {
                            table.eo = existingPair;
                            placed = true;
                        }
                    }
                }
            }

            // Place dragged pair in target position
            targetTableData[targetPos] = pair;

            // Recalculate IV averages after movement and re-render
            renderMitchellDisplay();
        }

        function highlightSimilarIVPositions(draggedIV) {
            const positions = document.querySelectorAll('.position[data-pair-id]');
            const otherPairs = [];

            // Collect all other pairs with their IV differences
            positions.forEach(position => {
                const pairId = position.dataset.pairId;
                const pair = findPairById(pairId);

                if (pair && pair.id !== draggedPair.id) {
                    const ivDiff = Math.abs(pair.combinedIV - draggedIV);
                    otherPairs.push({ position, pair, ivDiff });
                }
            });

            if (otherPairs.length === 0) return;

            // Sort by IV difference (smallest first)
            otherPairs.sort((a, b) => a.ivDiff - b.ivDiff);

            // Assign colors based on relative differences
            const totalPairs = otherPairs.length;

            otherPairs.forEach((item, index) => {
                let colorClass;

                if (totalPairs === 1) {
                    colorClass = 'similarity-green';
                } else if (totalPairs === 2) {
                    colorClass = index === 0 ? 'similarity-green' : 'similarity-red';
                } else {
                    // For 3+ pairs: best third = green, middle third = orange, worst third = red
                    const greenThreshold = Math.ceil(totalPairs / 3);
                    const orangeThreshold = Math.ceil((totalPairs * 2) / 3);

                    if (index < greenThreshold) {
                        colorClass = 'similarity-green';
                    } else if (index < orangeThreshold) {
                        colorClass = 'similarity-orange';
                    } else {
                        colorClass = 'similarity-red';
                    }
                }

                item.position.classList.add(colorClass);
            });
        }

        function clearIVHighlights() {
            const positions = document.querySelectorAll('.position');
            positions.forEach(position => {
                position.classList.remove('similarity-green', 'similarity-orange', 'similarity-red');
            });
        }

        // Close to config view
        function closeToConfig() {
            // Exit fullscreen if active
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(err => {
                    console.error('Error exiting fullscreen:', err);
                });
            }
            // Return to setup view
            showSetupView();
        }

        // Enter fullscreen automatically when showing mitchell view
        function enterFullscreen() {
            const elem = document.documentElement;
            if (!document.fullscreenElement) {
                elem.requestFullscreen().catch(err => {
                    console.log('Fullscreen not available:', err.message);
                });
            }
        }

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', function() {
            console.log('Fullscreen changed:', document.fullscreenElement !== null);
        });

        // Section configuration functions
        function changeSectionCount() {
            const newSectionCount = parseInt(document.getElementById('sectionCountSelect').value);
            console.log('üîÑ Changing section count to:', newSectionCount);

            // Update global section count
            currentSectionCount = newSectionCount;

            // Regenerate distribution with new section count
            if (parsedPairs && parsedPairs.length > 0) {
                showStatus('Redistribution en cours...', 'info');

                try {
                    // Create new distribution with updated section count
                    mitchellData = mitchellDistribution(parsedPairs, currentSectionCount, nsConstraints.size > 0);

                    // Update display
                    renderMitchellDisplay();

                    showStatus(`Redistribu√© en ${currentSectionCount} section(s)`, 'success');
                    hideStatus();
                } catch (error) {
                    console.error('Error redistributing:', error);
                    showStatus('Erreur lors de la redistribution', 'error');
                }
            }
        }

        function setSectionCount(count) {
            console.log('üîÑ setSectionCount called with:', count);

            // Remove active class from all section buttons
            document.querySelectorAll('.section-btn').forEach(btn => btn.classList.remove('active'));

            // Add active class to clicked button
            const btn = document.getElementById('sections' + count);
            if (btn) btn.classList.add('active');

            // Update global section count directly
            currentSectionCount = count;

            // Update hidden select for compatibility
            const select = document.getElementById('sectionCountSelect');
            if (select) select.value = count;

            // Regenerate distribution if we have data
            if (parsedPairs && parsedPairs.length > 0) {
                console.log('üîÑ Regenerating with', count, 'sections');
                try {
                    mitchellData = mitchellDistribution(parsedPairs, count, nsConstraints.size > 0);
                    renderMitchellDisplay();
                    console.log('‚úÖ Redistribution complete');
                } catch (error) {
                    console.error('‚ùå Error redistributing:', error);
                }
            }
        }

        // Track pending changes
        let pendingTableCounts = null;
        let originalTableCounts = null;

        function adjustTableCount(sectionIndex, delta) {
            if (currentSectionCount <= 1) return;

            // Initialize pending counts if not set
            if (!pendingTableCounts) {
                pendingTableCounts = mitchellData.map(section =>
                    section.filter(t => t.ns || t.eo).length
                );
                originalTableCounts = [...pendingTableCounts];
            }

            const minTables = 2;
            const totalPairs = parsedPairs.length;
            const maxTablesPerSection = Math.ceil(totalPairs / currentSectionCount);

            // Calculate new count
            let newCount = pendingTableCounts[sectionIndex] + delta;
            newCount = Math.max(minTables, Math.min(maxTablesPerSection, newCount));

            if (newCount === pendingTableCounts[sectionIndex]) return;

            // Adjust adjacent section cyclically
            const nextSectionIndex = (sectionIndex + 1) % currentSectionCount;
            const counterDelta = -delta;

            pendingTableCounts[sectionIndex] = newCount;
            pendingTableCounts[nextSectionIndex] = Math.max(minTables,
                pendingTableCounts[nextSectionIndex] + counterDelta);

            // Update display and check if we're back to original
            updateTableCountDisplay();
            checkPendingChangesStatus();
        }

        function updateTableCountDisplay() {
            if (!pendingTableCounts || !originalTableCounts) return;

            document.querySelectorAll('.table-count-value').forEach((el, index) => {
                if (pendingTableCounts[index] !== undefined) {
                    el.textContent = pendingTableCounts[index];

                    // Add/remove flash class based on modification status
                    if (pendingTableCounts[index] !== originalTableCounts[index]) {
                        el.classList.add('modified');
                    } else {
                        el.classList.remove('modified');
                    }
                }
            });
        }

        function checkPendingChangesStatus() {
            if (!pendingTableCounts || !originalTableCounts) return;

            // Check if all values are back to original
            const allOriginal = pendingTableCounts.every((count, index) =>
                count === originalTableCounts[index]
            );

            const cartouche = document.getElementById('pendingChanges');
            if (allOriginal) {
                // Hide cartouche and reset
                if (cartouche) cartouche.classList.add('hidden');
                // Remove all flash effects
                document.querySelectorAll('.table-count-value.modified').forEach(el => {
                    el.classList.remove('modified');
                });
            } else {
                // Show cartouche
                if (cartouche) cartouche.classList.remove('hidden');
            }
        }

        function showPendingChanges() {
            const cartouche = document.getElementById('pendingChanges');
            if (cartouche) {
                cartouche.classList.remove('hidden');
            }
        }

        function hidePendingChanges() {
            const cartouche = document.getElementById('pendingChanges');
            if (cartouche) {
                cartouche.classList.add('hidden');
            }
            // Remove all flash effects
            document.querySelectorAll('.table-count-value.modified').forEach(el => {
                el.classList.remove('modified');
            });
            pendingTableCounts = null;
            originalTableCounts = null;
        }

        function applyPendingChanges() {
            if (pendingTableCounts && parsedPairs.length > 0) {
                console.log('üîÑ Applying pending table counts:', pendingTableCounts, 'Algo:', currentAlgorithm);
                try {
                    // Use smart distribution which respects current algorithm choice
                    mitchellData = smartDistribution(parsedPairs, pendingTableCounts, nsConstraints.size > 0);
                    renderMitchellDisplay();
                    console.log('‚úÖ Redistribution appliqu√©e avec algo:', currentAlgorithm);
                } catch (error) {
                    console.error('‚ùå Erreur:', error);
                    // Fallback to standard distribution
                    mitchellData = mitchellDistribution(parsedPairs, currentSectionCount, nsConstraints.size > 0);
                    renderMitchellDisplay();
                }
            }
            hidePendingChanges();
        }

        function cancelPendingChanges() {
            // Restore original display
            if (originalTableCounts) {
                pendingTableCounts = [...originalTableCounts];
                updateTableCountDisplay();
            }
            hidePendingChanges();
            renderMitchellDisplay();
        }

        // Custom distribution with specific table counts per section - Algo 147
        function mitchellDistributionWithTableCounts(pairs, tableCounts, useConstraints) {
            console.log('üîÑ MITCHELL 147 avec table counts:', tableCounts, 'Contraintes NS:', nsConstraints.size);

            const numSections = tableCounts.length;

            // Sort pairs by IV and add metadata
            const sortedPairs = [...pairs].sort((a, b) => calculateCombinedIV(b) - calculateCombinedIV(a));
            sortedPairs.forEach((pair, i) => {
                if (!pair.id) pair.id = `pair_${i}`;
                pair.combinedIV = calculateCombinedIV(pair);
                pair.nsConstraint = nsConstraints.has(pair.id);
            });

            // Separate NS-constrained pairs from free pairs
            const nsConstrainedPairs = sortedPairs.filter(p => p.nsConstraint);
            const freePairs = sortedPairs.filter(p => !p.nsConstraint);

            console.log('üîí NS Contraints:', nsConstrainedPairs.length, 'Libres:', freePairs.length);

            // Create sections with specified table counts
            const sections = tableCounts.map(count => {
                const sectionTables = [];
                for (let i = 0; i < count; i++) {
                    sectionTables.push({
                        tableNumber: i + 1,
                        ns: null,
                        eo: null
                    });
                }
                return sectionTables;
            });

            // Step 1: Place NS-constrained pairs first (in NS positions)
            let constraintIdx = 0;
            for (let sectionIdx = 0; sectionIdx < numSections && constraintIdx < nsConstrainedPairs.length; sectionIdx++) {
                const section = sections[sectionIdx];
                const tablesInSection = section.length;

                // Distribute constrained pairs using Mitchell 1-4-7 pattern within section
                const mitchellSeq = generateMitchellSequence(tablesInSection);

                for (let i = 0; i < mitchellSeq.length && constraintIdx < nsConstrainedPairs.length; i++) {
                    const tableNum = mitchellSeq[i];
                    const table = section[tableNum - 1];

                    if (table && !table.ns) {
                        table.ns = nsConstrainedPairs[constraintIdx++];
                        console.log(`üîí NS Fixe: Section ${sectionIdx}, Table ${tableNum}`);
                    }
                }
            }

            // Step 2: Fill remaining positions with free pairs using 1-4-7 pattern
            let freeIdx = 0;

            for (let sectionIdx = 0; sectionIdx < numSections; sectionIdx++) {
                const section = sections[sectionIdx];
                const tablesInSection = section.length;
                const mitchellSeq = generateMitchellSequence(tablesInSection);

                // Fill NS positions first (following Mitchell sequence)
                for (let i = 0; i < mitchellSeq.length && freeIdx < freePairs.length; i++) {
                    const tableNum = mitchellSeq[i];
                    const table = section[tableNum - 1];

                    if (table && !table.ns) {
                        table.ns = freePairs[freeIdx++];
                    }
                }

                // Then fill EO positions (following Mitchell sequence)
                for (let i = 0; i < mitchellSeq.length && freeIdx < freePairs.length; i++) {
                    const tableNum = mitchellSeq[i];
                    const table = section[tableNum - 1];

                    if (table && !table.eo) {
                        table.eo = freePairs[freeIdx++];
                    }
                }
            }

            console.log('‚úÖ Distribution 147 termin√©e');
            return sections;
        }

        // =====================================================
        // NOUVEL ALGORITHME √âQUILIBR√â (?)
        // Objectif: minimiser les diff√©rentiels d'IV entre sections et lignes NS/EO
        // M√©thode: Distribution en serpentin avec √©quilibrage
        // =====================================================

        let currentAlgorithm = '1-4-7'; // Default

        function balancedDistribution(pairs, tableCounts, useConstraints) {
            console.log('üéØ ALGO √âQUILIBR√â: D√©marrage avec', pairs.length, 'paires');
            console.log('üìä Table counts:', tableCounts);

            const numSections = tableCounts.length;

            // Sort pairs by IV DESC
            const sortedPairs = [...pairs].sort((a, b) => calculateCombinedIV(b) - calculateCombinedIV(a));
            sortedPairs.forEach((pair, i) => {
                if (!pair.id) pair.id = `pair_${i}`;
                pair.combinedIV = calculateCombinedIV(pair);
                pair.nsConstraint = nsConstraints.has(pair.id);
            });

            // Separate constrained from free pairs
            const nsConstrainedPairs = sortedPairs.filter(p => p.nsConstraint);
            const freePairs = sortedPairs.filter(p => !p.nsConstraint);

            // Create sections with specified table counts
            const sections = tableCounts.map(count => {
                const sectionTables = [];
                for (let i = 0; i < count; i++) {
                    sectionTables.push({
                        tableNumber: i + 1,
                        ns: null,
                        eo: null
                    });
                }
                return sectionTables;
            });

            // Calculate total positions per section (NS + EO)
            const positionsPerSection = tableCounts.map(count => count * 2);
            const totalPositions = positionsPerSection.reduce((a, b) => a + b, 0);

            console.log('üìä Positions par section:', positionsPerSection);

            // Step 1: Place NS-constrained pairs in NS positions (distribute across sections)
            if (nsConstrainedPairs.length > 0) {
                let constraintIdx = 0;
                // Distribute evenly across sections using serpentin
                const sectionOrder = generateSerpentinOrder(numSections, nsConstrainedPairs.length);

                for (let i = 0; i < sectionOrder.length && constraintIdx < nsConstrainedPairs.length; i++) {
                    const sectionIdx = sectionOrder[i];
                    const section = sections[sectionIdx];

                    // Find first empty NS position in this section
                    for (let tableIdx = 0; tableIdx < section.length; tableIdx++) {
                        if (!section[tableIdx].ns) {
                            section[tableIdx].ns = nsConstrainedPairs[constraintIdx++];
                            break;
                        }
                    }
                }
            }

            // Step 2: Distribute free pairs using "serpentin √©quilibr√©"
            // Alternate between sections and NS/EO to balance IV

            // Build list of all empty positions: {section, table, position (ns/eo)}
            const emptyPositions = [];
            for (let s = 0; s < numSections; s++) {
                for (let t = 0; t < sections[s].length; t++) {
                    if (!sections[s][t].ns) emptyPositions.push({ s, t, pos: 'ns' });
                }
                for (let t = 0; t < sections[s].length; t++) {
                    if (!sections[s][t].eo) emptyPositions.push({ s, t, pos: 'eo' });
                }
            }

            // Sort positions to create balanced serpentin:
            // Round-robin: Section 0 NS, Section 1 NS, Section 2 NS, Section 0 EO, Section 1 EO...
            // Then snake back for next round
            const balancedPositions = createBalancedPositionOrder(sections, numSections);

            // Place free pairs in balanced order
            let freeIdx = 0;
            for (const pos of balancedPositions) {
                if (freeIdx >= freePairs.length) break;

                const table = sections[pos.s][pos.t];
                if (pos.pos === 'ns' && !table.ns) {
                    table.ns = freePairs[freeIdx++];
                } else if (pos.pos === 'eo' && !table.eo) {
                    table.eo = freePairs[freeIdx++];
                }
            }

            // Log statistics
            logDistributionStats(sections);

            return sections;
        }

        // Generate serpentin order for distributing across sections
        function generateSerpentinOrder(numSections, count) {
            const order = [];
            let forward = true;

            while (order.length < count) {
                if (forward) {
                    for (let s = 0; s < numSections && order.length < count; s++) {
                        order.push(s);
                    }
                } else {
                    for (let s = numSections - 1; s >= 0 && order.length < count; s--) {
                        order.push(s);
                    }
                }
                forward = !forward;
            }

            return order;
        }

        // Create balanced position order for optimal IV distribution
        function createBalancedPositionOrder(sections, numSections) {
            const positions = [];

            // Count max tables across sections
            const maxTables = Math.max(...sections.map(s => s.length));

            // Serpentin: distribute by table index across sections, alternating direction
            // This ensures top IV pairs are spread across sections and NS/EO

            // First pass: All NS positions in serpentin
            for (let t = 0; t < maxTables; t++) {
                const forward = t % 2 === 0;
                if (forward) {
                    for (let s = 0; s < numSections; s++) {
                        if (t < sections[s].length && !sections[s][t].ns) {
                            positions.push({ s, t, pos: 'ns' });
                        }
                    }
                } else {
                    for (let s = numSections - 1; s >= 0; s--) {
                        if (t < sections[s].length && !sections[s][t].ns) {
                            positions.push({ s, t, pos: 'ns' });
                        }
                    }
                }
            }

            // Second pass: All EO positions in serpentin (reversed direction)
            for (let t = 0; t < maxTables; t++) {
                const forward = t % 2 === 1; // Inverted from NS
                if (forward) {
                    for (let s = 0; s < numSections; s++) {
                        if (t < sections[s].length && !sections[s][t].eo) {
                            positions.push({ s, t, pos: 'eo' });
                        }
                    }
                } else {
                    for (let s = numSections - 1; s >= 0; s--) {
                        if (t < sections[s].length && !sections[s][t].eo) {
                            positions.push({ s, t, pos: 'eo' });
                        }
                    }
                }
            }

            return positions;
        }

        // Log distribution statistics for debugging
        function logDistributionStats(sections) {
            console.log('üìä === STATISTIQUES DE DISTRIBUTION ===');

            for (let s = 0; s < sections.length; s++) {
                const section = sections[s];
                let nsTotal = 0, eoTotal = 0, nsCount = 0, eoCount = 0;

                for (const table of section) {
                    if (table.ns) { nsTotal += table.ns.combinedIV || 0; nsCount++; }
                    if (table.eo) { eoTotal += table.eo.combinedIV || 0; eoCount++; }
                }

                const nsAvg = nsCount > 0 ? (nsTotal / nsCount).toFixed(1) : 0;
                const eoAvg = eoCount > 0 ? (eoTotal / eoCount).toFixed(1) : 0;
                const sectionTotal = nsTotal + eoTotal;
                const diff = Math.abs(nsTotal - eoTotal);

                console.log(`Section ${String.fromCharCode(65 + s)}: Total=${sectionTotal}, NS=${nsTotal}(~${nsAvg}), EO=${eoTotal}(~${eoAvg}), Diff=${diff}`);
            }

            // Calculate global balance
            const sectionTotals = sections.map(section => {
                let total = 0;
                for (const table of section) {
                    if (table.ns) total += table.ns.combinedIV || 0;
                    if (table.eo) total += table.eo.combinedIV || 0;
                }
                return total;
            });

            const maxSection = Math.max(...sectionTotals);
            const minSection = Math.min(...sectionTotals);
            console.log(`üìä √âcart entre sections: ${maxSection - minSection} (Max: ${maxSection}, Min: ${minSection})`);
        }

        // Wrapper function that chooses algorithm based on current selection
        function smartDistribution(pairs, tableCounts, useConstraints) {
            if (currentAlgorithm === '1-4-7') {
                return mitchellDistributionWithTableCounts(pairs, tableCounts, useConstraints);
            } else {
                return balancedDistribution(pairs, tableCounts, useConstraints);
            }
        }

        function setAlgorithm(algo) {
            // Remove active class from all algo buttons
            document.querySelectorAll('.algo-btn').forEach(btn => btn.classList.remove('active'));

            // Add active class to clicked button
            if (algo === '1-4-7') {
                document.getElementById('algo147').classList.add('active');
                currentAlgorithm = '1-4-7';
            } else {
                document.getElementById('algoNew').classList.add('active');
                currentAlgorithm = 'balanced';
            }

            // Store algorithm preference
            localStorage.setItem('bridgeAlgorithm', algo);

            // Regenerate if we have data
            if (parsedPairs && parsedPairs.length > 0) {
                const tableCounts = mitchellData.map(section =>
                    section.filter(t => t.ns || t.eo).length
                );
                mitchellData = smartDistribution(parsedPairs, tableCounts, nsConstraints.size > 0);
                renderMitchellDisplay();
                showStatus(`Algorithme ${algo === '1-4-7' ? 'Mitchell 1-4-7' : '√âquilibr√©'} appliqu√©`, 'success');
            } else {
                showStatus(`Algorithme chang√©: ${algo}`, 'info');
            }
        }

        // Toggle card details display
        function toggleCardDetails(cardElement, event) {
            // Prevent the NS constraint toggle for click on details
            if (event && event.shiftKey) {
                // Shift+click for NS constraint
                return;
            }

            // Toggle show-details class
            cardElement.classList.toggle('show-details');

            // Optional: Auto-hide details after a few seconds
            if (cardElement.classList.contains('show-details')) {
                setTimeout(() => {
                    cardElement.classList.remove('show-details');
                }, 5000);
            }
        }

        // Initialize section count selector with current value
        function initializeSectionControls() {
            const selector = document.getElementById('sectionCountSelect');
            if (selector && currentSectionCount) {
                selector.value = currentSectionCount.toString();
            }
        }

        // Add drag target styling
        function addDragTargetStyling(cardElement) {
            cardElement.classList.add('drag-target');
        }

        // Remove drag target styling
        function removeDragTargetStyling(cardElement) {
            cardElement.classList.remove('drag-target');
        }

        // Constraint system functions
        function initializeConstraintSystem() {
            // Enable click-to-constraint functionality
            updateConstraintDisplay();
        }

        function toggleNSConstraint(pairId) {
            // Allow toggle for any pair - NS or EO
            if (nsConstraints.has(pairId)) {
                nsConstraints.delete(pairId);
                console.log('üîí DEBUG: Removed constraint from pair:', pairId);
            } else {
                nsConstraints.add(pairId);
                console.log('üîí DEBUG: Added constraint to pair:', pairId);
            }

            updateConstraintDisplay();
            renderMitchellDisplay(); // Re-render to show visual changes
        }

        function updateConstraintDisplay() {
            const countEl = document.getElementById('constraintCount');
            if (countEl) {
                countEl.textContent = `${nsConstraints.size} paire(s) marqu√©e(s)`;
            }
        }

        function showConstraintControls() {
            document.getElementById('constraintControls').style.display = 'block';
            stopAutoPage(); // Stop auto-pagination when in constraint mode
        }

        function hideConstraintControls() {
            document.getElementById('constraintControls').style.display = 'none';
        }

        function clearConstraints() {
            nsConstraints.clear();
            // Refaire la distribution initiale comme au d√©but
            if (parsedPairs && parsedPairs.length > 0) {
                // Reset constraint status for all pairs
                parsedPairs.forEach(pair => {
                    pair.nsConstraint = false;
                    pair.mustBeNS = false;
                });

                // Generate fresh distribution without any constraints
                mitchellData = mitchellDistribution(parsedPairs, currentSectionCount, false);
                renderMitchellDisplay();
            }
        }

        // Allow redistribution even without constraints (useful for rebalancing)
        function redistributeAll() {
            redistributeWithConstraints(); // The function now handles both cases automatically
        }

        // Generate test data for 35 pairs
        function generateTestData() {
            const names = [
                'MARTIN Pierre', 'BERNARD Marie', 'THOMAS Jean', 'DUBOIS Anne',
                'ROBERT Paul', 'PETIT Claire', 'RICHARD Michel', 'MOREAU Sophie',
                'SIMON Philippe', 'LAURENT Christine', 'LEFEVRE Alain', 'MICHEL Brigitte',
                'GARCIA Carlos', 'DAVID Francine', 'BERTRAND Luc', 'ROUX Monique',
                'FOURNIER Henri', 'GIRARD Nicole', 'BONNET Andre', 'DUPONT Jacqueline',
                'LAMBERT Denis', 'FONTAINE Sylvie', 'ROUSSEAU Gerard', 'VINCENT Martine',
                'MULLER Hans', 'LEROY Danielle', 'FABRE Claude', 'ANDRE Catherine',
                'MERCIER Roger', 'BLANC Isabelle', 'GUERIN Marcel', 'BOYER Yvette',
                'CLEMENT Francis', 'CHEVALIER Odette', 'FRANCOIS Raymond', 'GAUTHIER Helene',
                'PERRIN Yves', 'MOREL Simone', 'ROBIN Fernand', 'COLIN Jeanne',
                'LECLERC Maurice', 'BARBIER Suzanne', 'ARNAUD Robert', 'MARTINEZ Carmen',
                'GAILLARD Henri', 'BRUN Marguerite', 'GARNIER Louis', 'FAURE Marie-Claire',
                'LEMAIRE Antoine', 'ROUSSEL Georgette', 'GIRAUD Pierre', 'HENRY Solange',
                'REY Jean-Claude', 'PEREZ Dolores', 'MOULIN Bernard', 'HUBERT Denise',
                'LUCAS Serge', 'DUFOUR Madeleine', 'BRUNET Charles', 'MARTIN Colette',
                'SCHMITT Fritz', 'RODRIGUEZ Maria', 'COLIN Patrick', 'LEROUX Paulette',
                'AUBRY Christian', 'PICARD Therese', 'GUYOT Rene', 'MEUNIER Lucette',
                'BARRE Emile', 'CHARLES Raymonde', 'RENAUD Albert', 'PHILIPPE Andree'
            ];

            let testData = 'Tournoi Bridge Club Nancy - Test 35 paires du 13/01/2026 √† 14:15\n';
            testData += '35 √©quipe(s)\n';
            testData += 'Nouvelle √©quipe\n';
            testData += 'Inscription    Joueur 1    Joueur 2    Actions\n';

            // DONN√âES FIXES - Plus jamais de Math.random() !
            testData += '13/01/2026 14:15\nM. MARTIN Pierre ( 5.00 ‚Ç¨ )\n00000001 ( IV = 190 )\nMme BERNARD Marie ( 5.00 ‚Ç¨ )\n00000002 ( IV = 187 )\nInscription\n';
            testData += '13/01/2026 14:20\nM. THOMAS Jean ( 5.00 ‚Ç¨ )\n00000003 ( IV = 185 )\nMme DUBOIS Anne ( 5.00 ‚Ç¨ )\n00000004 ( IV = 183 )\nInscription\n';
            testData += '13/01/2026 14:25\nM. ROBERT Paul ( 5.00 ‚Ç¨ )\n00000005 ( IV = 180 )\nMme PETIT Claire ( 5.00 ‚Ç¨ )\n00000006 ( IV = 178 )\nInscription\n';
            testData += '13/01/2026 14:30\nM. RICHARD Michel ( 5.00 ‚Ç¨ )\n00000007 ( IV = 175 )\nMme MOREAU Sophie ( 5.00 ‚Ç¨ )\n00000008 ( IV = 173 )\nInscription\n';
            testData += '13/01/2026 14:35\nM. SIMON Philippe ( 5.00 ‚Ç¨ )\n00000009 ( IV = 170 )\nMme LAURENT Christine ( 5.00 ‚Ç¨ )\n00000010 ( IV = 168 )\nInscription\n';
            testData += '13/01/2026 14:40\nM. LEFEVRE Alain ( 5.00 ‚Ç¨ )\n00000011 ( IV = 165 )\nMme MICHEL Brigitte ( 5.00 ‚Ç¨ )\n00000012 ( IV = 163 )\n';
            testData += '13/01/2026 14:45\nM. GARCIA Carlos ( 5.00 ‚Ç¨ )\n00000013 ( IV = 160 )\nMme DAVID Francine ( 5.00 ‚Ç¨ )\n00000014 ( IV = 158 )\n';
            testData += '13/01/2026 14:50\nM. BERTRAND Luc ( 5.00 ‚Ç¨ )\n00000015 ( IV = 155 )\nMme ROUX Monique ( 5.00 ‚Ç¨ )\n00000016 ( IV = 153 )\n';
            testData += '13/01/2026 14:55\nM. FOURNIER Henri ( 5.00 ‚Ç¨ )\n00000017 ( IV = 150 )\nMme GIRARD Nicole ( 5.00 ‚Ç¨ )\n00000018 ( IV = 148 )\n';
            testData += '13/01/2026 15:00\nM. BONNET Andre ( 5.00 ‚Ç¨ )\n00000019 ( IV = 145 )\nMme DUPONT Jacqueline ( 5.00 ‚Ç¨ )\n00000020 ( IV = 143 )\n';
            testData += '13/01/2026 15:05\nM. LAMBERT Denis ( 5.00 ‚Ç¨ )\n00000021 ( IV = 140 )\nMme FONTAINE Sylvie ( 5.00 ‚Ç¨ )\n00000022 ( IV = 138 )\n';
            testData += '13/01/2026 15:10\nM. ROUSSEAU Gerard ( 5.00 ‚Ç¨ )\n00000023 ( IV = 135 )\nMme VINCENT Martine ( 5.00 ‚Ç¨ )\n00000024 ( IV = 133 )\n';
            testData += '13/01/2026 15:15\nM. MULLER Hans ( 5.00 ‚Ç¨ )\n00000025 ( IV = 130 )\nMme LEROY Danielle ( 5.00 ‚Ç¨ )\n00000026 ( IV = 128 )\n';
            testData += '13/01/2026 15:20\nM. FABRE Claude ( 5.00 ‚Ç¨ )\n00000027 ( IV = 125 )\nMme ANDRE Catherine ( 5.00 ‚Ç¨ )\n00000028 ( IV = 123 )\n';
            testData += '13/01/2026 15:25\nM. MERCIER Roger ( 5.00 ‚Ç¨ )\n00000029 ( IV = 120 )\nMme BLANC Isabelle ( 5.00 ‚Ç¨ )\n00000030 ( IV = 118 )\n';
            testData += '13/01/2026 15:30\nM. GUERIN Marcel ( 5.00 ‚Ç¨ )\n00000031 ( IV = 115 )\nMme BOYER Yvette ( 5.00 ‚Ç¨ )\n00000032 ( IV = 113 )\n';
            testData += '13/01/2026 15:35\nM. CLEMENT Francis ( 5.00 ‚Ç¨ )\n00000033 ( IV = 110 )\nMme CHEVALIER Odette ( 5.00 ‚Ç¨ )\n00000034 ( IV = 108 )\n';
            testData += '13/01/2026 15:40\nM. FRANCOIS Raymond ( 5.00 ‚Ç¨ )\n00000035 ( IV = 105 )\nMme GAUTHIER Helene ( 5.00 ‚Ç¨ )\n00000036 ( IV = 103 )\n';
            testData += '13/01/2026 15:45\nM. PERRIN Yves ( 5.00 ‚Ç¨ )\n00000037 ( IV = 100 )\nMme MOREL Simone ( 5.00 ‚Ç¨ )\n00000038 ( IV = 98 )\n';
            testData += '13/01/2026 15:50\nM. ROBIN Fernand ( 5.00 ‚Ç¨ )\n00000039 ( IV = 95 )\nMme COLIN Jeanne ( 5.00 ‚Ç¨ )\n00000040 ( IV = 93 )\n';
            testData += '13/01/2026 15:55\nM. LECLERC Maurice ( 5.00 ‚Ç¨ )\n00000041 ( IV = 90 )\nMme BARBIER Suzanne ( 5.00 ‚Ç¨ )\n00000042 ( IV = 88 )\n';
            testData += '13/01/2026 16:00\nM. ARNAUD Robert ( 5.00 ‚Ç¨ )\n00000043 ( IV = 85 )\nMme MARTINEZ Carmen ( 5.00 ‚Ç¨ )\n00000044 ( IV = 83 )\n';
            testData += '13/01/2026 16:05\nM. GAILLARD Henri ( 5.00 ‚Ç¨ )\n00000045 ( IV = 80 )\nMme BRUN Marguerite ( 5.00 ‚Ç¨ )\n00000046 ( IV = 78 )\n';
            testData += '13/01/2026 16:10\nM. GARNIER Louis ( 5.00 ‚Ç¨ )\n00000047 ( IV = 75 )\nMme FAURE Marie-Claire ( 5.00 ‚Ç¨ )\n00000048 ( IV = 73 )\n';
            testData += '13/01/2026 16:15\nM. LEMAIRE Antoine ( 5.00 ‚Ç¨ )\n00000049 ( IV = 70 )\nMme ROUSSEL Georgette ( 5.00 ‚Ç¨ )\n00000050 ( IV = 68 )\n';
            testData += '13/01/2026 16:20\nM. GIRAUD Pierre ( 5.00 ‚Ç¨ )\n00000051 ( IV = 65 )\nMme HENRY Solange ( 5.00 ‚Ç¨ )\n00000052 ( IV = 63 )\n';
            testData += '13/01/2026 16:25\nM. REY Jean-Claude ( 5.00 ‚Ç¨ )\n00000053 ( IV = 60 )\nMme PEREZ Dolores ( 5.00 ‚Ç¨ )\n00000054 ( IV = 58 )\n';
            testData += '13/01/2026 16:30\nM. MOULIN Bernard ( 2.50 ‚Ç¨ )\n00000055 ( IV = 55 )\nMme HUBERT Denise ( 5.00 ‚Ç¨ )\n00000056 ( IV = 53 )\n';
            testData += '13/01/2026 16:35\nM. LUCAS Serge ( 5.00 ‚Ç¨ )\n00000057 ( IV = 50 )\nMme DUFOUR Madeleine ( 5.00 ‚Ç¨ )\n00000058 ( IV = 48 )\n';
            testData += '13/01/2026 16:40\nM. BRUNET Charles ( 5.00 ‚Ç¨ )\n00000059 ( IV = 45 )\nMme MARTIN Colette ( 5.00 ‚Ç¨ )\n00000060 ( IV = 43 )\n';
            testData += '13/01/2026 16:45\nM. SCHMITT Fritz ( 5.00 ‚Ç¨ )\n00000061 ( IV = 40 )\nMme RODRIGUEZ Maria ( 5.00 ‚Ç¨ )\n00000062 ( IV = 38 )\n';
            testData += '13/01/2026 16:50\nM. COLIN Patrick ( 2.50 ‚Ç¨ )\n00000063 ( IV = 35 )\nMme LEROUX Paulette ( 5.00 ‚Ç¨ )\n00000064 ( IV = 33 )\n';
            testData += '13/01/2026 16:55\nM. AUBRY Christian ( 5.00 ‚Ç¨ )\n00000065 ( IV = 30 )\nMme PICARD Therese ( 0.00 ‚Ç¨ )\n00000066 ( IV = 28 )\n';
            testData += '13/01/2026 17:00\nM. GUYOT Rene ( 5.00 ‚Ç¨ )\n00000067 ( IV = 25 )\nMme MEUNIER Lucette ( 5.00 ‚Ç¨ )\n00000068 ( IV = 23 )\n';
            testData += '13/01/2026 17:05\nM. BARRE Emile ( 2.50 ‚Ç¨ )\n00000069 ( IV = 20 )\nMme CHARLES Raymonde ( 2.50 ‚Ç¨ )\n00000070 ( IV = 18 )\nInscription\n';

            return testData;
        }

        function generateTestData80() {
            const names = [
                'MARTIN Pierre', 'BERNARD Marie', 'THOMAS Jean', 'DUBOIS Anne',
                'ROBERT Paul', 'PETIT Claire', 'RICHARD Michel', 'MOREAU Sophie',
                'SIMON Philippe', 'LAURENT Christine', 'LEFEVRE Alain', 'MICHEL Brigitte',
                'GARCIA Carlos', 'DAVID Francine', 'BERTRAND Luc', 'ROUX Monique',
                'FOURNIER Henri', 'GIRARD Nicole', 'BONNET Andre', 'DUPONT Jacqueline',
                'LAMBERT Denis', 'FONTAINE Sylvie', 'ROUSSEAU Gerard', 'VINCENT Martine',
                'MULLER Hans', 'LEROY Danielle', 'FABRE Claude', 'ANDRE Catherine',
                'MERCIER Roger', 'BLANC Isabelle', 'GUERIN Marcel', 'BOYER Yvette',
                'CLEMENT Francis', 'CHEVALIER Odette', 'FRANCOIS Raymond', 'GAUTHIER Helene',
                'PERRIN Yves', 'MOREL Simone', 'ROBIN Fernand', 'COLIN Jeanne',
                'LECLERC Maurice', 'BARBIER Suzanne', 'ARNAUD Robert', 'MARTINEZ Carmen',
                'GAILLARD Henri', 'BRUN Marguerite', 'GARNIER Louis', 'FAURE Marie-Claire',
                'LEMAIRE Antoine', 'ROUSSEL Georgette', 'GIRAUD Pierre', 'HENRY Solange',
                'REY Jean-Claude', 'PEREZ Dolores', 'MOULIN Bernard', 'HUBERT Denise',
                'LUCAS Serge', 'DUFOUR Madeleine', 'BRUNET Charles', 'MARTIN Colette',
                'SCHMITT Fritz', 'RODRIGUEZ Maria', 'COLIN Patrick', 'LEROUX Paulette',
                'AUBRY Christian', 'PICARD Therese', 'GUYOT Rene', 'MEUNIER Lucette',
                'BARRE Emile', 'CHARLES Raymonde', 'RENAUD Albert', 'PHILIPPE Andree',
                'DURAND Michel', 'MOREAU Elisabeth', 'LEBLANC Jean-Pierre', 'DUBOIS Francoise',
                'BONNET Laurent', 'ROUX Catherine', 'CLAUDE Pierre', 'MARTIN Sophie',
                'BERNARD Jacques', 'PETIT Nicole', 'ROBERT Antoine', 'GIRARD Sylvie',
                'THOMAS Philippe', 'DUBOIS Monique', 'RICHARD Jean', 'MOREAU Brigitte',
                'SIMON Claude', 'LAURENT Danielle', 'LEFEVRE Paul', 'MICHEL Christine',
                'GARCIA Jean-Luc', 'DAVID Marie-Claire', 'BERTRAND Henri', 'ROUX Isabelle',
                'FOURNIER Louis', 'GIRARD Martine', 'BONNET Christian', 'DUPONT Suzanne',
                'LAMBERT Pierre', 'FONTAINE Marie', 'ROUSSEAU Michel', 'VINCENT Anne',
                'MULLER Paul', 'LEROY Christine', 'FABRE Jacques', 'ANDRE Sylvie',
                'MERCIER Jean', 'BLANC Marie-France', 'GUERIN Pierre', 'BOYER Catherine',
                'CLEMENT Jean-Claude', 'CHEVALIER Marie', 'FRANCOIS Paul', 'GAUTHIER Sophie',
                'PERRIN Michel', 'MOREL Danielle', 'ROBIN Jean-Pierre', 'COLIN Marie-Claire',
                'LECLERC Paul', 'BARBIER Nicole', 'ARNAUD Michel', 'MARTINEZ Francoise',
                'GAILLARD Jean', 'BRUN Catherine', 'GARNIER Pierre', 'FAURE Elisabeth',
                'LEMAIRE Michel', 'ROUSSEL Marie', 'GIRAUD Jean-Luc', 'HENRY Brigitte',
                'REY Pierre', 'PEREZ Marie-Carmen', 'MOULIN Jean', 'HUBERT Sophie',
                'LUCAS Michel', 'DUFOUR Catherine', 'BRUNET Jean-Pierre', 'MARTIN Marie-France',
                'SCHMITT Jean', 'RODRIGUEZ Carmen', 'COLIN Michel', 'LEROUX Marie-Claire',
                'AUBRY Jean-Luc', 'PICARD Nicole', 'GUYOT Pierre', 'MEUNIER Sylvie',
                'BARRE Jean', 'CHARLES Marie', 'RENAUD Michel', 'PHILIPPE Catherine',
                'MARCEL Antoine', 'LEBRUN Sophie', 'NICOLAS Pierre', 'MERCIER Marie',
                'PAULIN Jean', 'ROYER Catherine', 'JEAN Michel', 'LAURENT Marie-Francoise'
            ];

            let testData = 'Tournoi Bridge Club Nancy - Test 80 paires du ' + new Date().toLocaleDateString('fr-FR') + ' √† 14:15\n';
            testData += '80 √©quipe(s)\n';
            testData += 'Nouvelle √©quipe\n';
            testData += 'Inscription    Joueur 1    Joueur 2    Actions\n';

            for (let i = 0; i < 80; i++) {
                const date = new Date();
                date.setDate(date.getDate() - Math.floor(Math.random() * 7));
                const dateStr = date.toLocaleDateString('fr-FR').replace(/\//g, '/') + ' ' +
                    String(Math.floor(Math.random() * 24)).padStart(2, '0') + ':' +
                    String(Math.floor(Math.random() * 60)).padStart(2, '0');

                const player1Name = names[i * 2] || `Joueur${i * 2 + 1}`;
                const player2Name = names[i * 2 + 1] || `Joueur${i * 2 + 2}`;

                const player1IV = Math.floor(200 - (i * 1.2)) + Math.floor(Math.random() * 15) - 7;
                const player2IV = Math.floor(195 - (i * 1.2)) + Math.floor(Math.random() * 15) - 7;

                const player1Amount = Math.random() > 0.1 ? '5.00' : (Math.random() > 0.5 ? '2.50' : '0.00');
                const player2Amount = Math.random() > 0.1 ? '5.00' : (Math.random() > 0.5 ? '2.50' : '0.00');

                const license1 = `000${String(i * 2 + 1).padStart(5, '0')}`;
                const license2 = `000${String(i * 2 + 2).padStart(5, '0')}`;

                const prefix1 = Math.random() > 0.5 ? 'M.' : 'Mme';
                const prefix2 = Math.random() > 0.5 ? 'M.' : 'Mme';

                testData += `${dateStr}\n`;
                testData += `${prefix1} ${player1Name} ( ${player1Amount} ‚Ç¨ )\n`;
                testData += `${license1} ( IV = ${player1IV} )\n`;
                testData += `${prefix2} ${player2Name} ( ${player2Amount} ‚Ç¨ )\n`;
                testData += `${license2} ( IV = ${player2IV} )\n`;
                testData += 'Inscription\n';
            }

            return testData;
        }

        // DARK MODE - Version d√©finitive
        let isDarkMode = false;

        function forceDarkMode() {
            console.log('üåô DARK MODE CALLED, current state:', isDarkMode);

            const body = document.body;
            const btn = document.getElementById('darkModeBtn');

            isDarkMode = !isDarkMode;

            if (isDarkMode) {
                console.log('üåô Switching to DARK');
                body.style.cssText = 'background-color: #1a1a1a !important; color: #e0e0e0 !important;';
                body.className = 'dark-mode';
                localStorage.setItem('darkMode', 'true');
                if (btn) btn.textContent = '‚òÄÔ∏è Light';
            } else {
                console.log('üåô Switching to LIGHT');
                body.style.cssText = 'background-color: #ffffff !important; color: #000000 !important;';
                body.className = '';
                localStorage.setItem('darkMode', 'false');
                if (btn) btn.textContent = 'üåô Dark';
            }

            console.log('üåô New state:', isDarkMode);
            console.log('üåô Body background:', body.style.backgroundColor);
        }

        function updateButtonText(text) {
            const btn = document.getElementById('darkModeBtn');
            if (btn) {
                btn.textContent = text;
                console.log('üåô Button updated to:', text);
            }
        }

        function updateDarkModeButton(isDark) {
            const darkBtn = document.getElementById('darkModeBtn') ||
                           document.querySelector('button[onclick="toggleDarkMode()"]');
            if (darkBtn) {
                darkBtn.textContent = isDark ? '‚òÄÔ∏è Light' : 'üåô Dark';
                console.log('üåô DEBUG: Button text updated to:', darkBtn.textContent);
            } else {
                console.error('üåô ERROR: Dark mode button not found');
            }
        }

        // Page navigation functions
        function nextPage() {
            if (currentPage < totalPages) {
                currentPage++;
                renderMitchellDisplay();
            }
        }

        function prevPage() {
            if (currentPage > 1) {
                currentPage--;
                renderMitchellDisplay();
            }
        }

        function updatePageIndicator() {
            const indicator = document.getElementById('pageIndicator');
            if (indicator && totalPages > 1) {
                indicator.textContent = `Page ${currentPage}/${totalPages}`;
            }
        }

        function startAutoPage() {
            stopAutoPage(); // Clear any existing interval
            if (totalPages > 1) {
                autoPageInterval = setInterval(() => {
                    if (currentPage >= totalPages) {
                        currentPage = 1;
                    } else {
                        currentPage++;
                    }
                    renderMitchellDisplay();
                }, 3000); // Change page every 3 seconds
            }
        }

        function stopAutoPage() {
            if (autoPageInterval) {
                clearInterval(autoPageInterval);
                autoPageInterval = null;
            }
        }

        function toggleAutoPage() {
            if (autoPageInterval) {
                stopAutoPage();
            } else {
                startAutoPage();
            }
        }

        // FFB Extraction and Automation Functions
        function showFFBExtractor() {
            const helpDiv = document.getElementById('automationHelp');
            helpDiv.style.display = 'block';
            helpDiv.innerHTML = `
                <h6>üìã Extracteur FFB - Bookmarklet</h6>
                <p>1. <strong>Cr√©er le favori :</strong> Faites glisser ce lien vers votre barre de favoris :</p>
                <div style="background: #f8f9fa; padding: 8px; border-radius: 4px; font-family: monospace; font-size: 0.8em; margin: 8px 0;">
                    <a href="javascript:(function(){${generateBookmarklet()}})()"
                       style="color: #007bff; text-decoration: none;">
                       üìã FFB Extractor
                    </a>
                </div>
                <p>2. <strong>Utilisation :</strong> Sur ffbridge.fr, page tournoi, cliquez sur le favori</p>
                <p>3. <strong>R√©sultat :</strong> Les donn√©es sont automatiquement import√©es ici</p>
            `;
        }

        function initScreenCapture() {
            const helpDiv = document.getElementById('automationHelp');
            helpDiv.style.display = 'block';
            helpDiv.innerHTML = `
                <h6>üì∑ Capture d'√âcran Automatis√©e</h6>
                <div style="margin: 10px 0;">
                    <label><input type="radio" name="captureType" value="fixed" checked> Zone fixe (dimensions d√©finies)</label><br>
                    <label><input type="radio" name="captureType" value="scroll"> Page compl√®te (scroll automatique)</label>
                </div>
                <div style="margin: 10px 0;">
                    <label>Largeur: <input type="number" id="captureWidth" value="1200" style="width: 80px;"> px</label>
                    <label style="margin-left: 10px;">Hauteur: <input type="number" id="captureHeight" value="800" style="width: 80px;"> px</label>
                </div>
                <div style="margin: 10px 0;">
                    <label>Webhook n8n: <input type="url" id="n8nWebhook" placeholder="https://votre-n8n.fr/webhook/capture" style="width: 250px;"></label>
                </div>
                <button onclick="triggerCapture()" style="background: #28a745; color: white; border: none; padding: 6px 12px; border-radius: 4px;">
                    üöÄ Lancer Capture
                </button>
            `;
        }

        function setupN8NIntegration() {
            const helpDiv = document.getElementById('automationHelp');
            helpDiv.style.display = 'block';
            helpDiv.innerHTML = `
                <h6>üåê Int√©gration n8n</h6>
                <p><strong>Webhook de configuration :</strong></p>
                <input type="url" id="configWebhook" placeholder="https://votre-n8n.fr/webhook/bridge-config" style="width: 100%; margin: 5px 0;">
                <p><strong>Param√®tres disponibles :</strong></p>
                <textarea id="configParams" style="width: 100%; height: 120px; font-family: monospace; font-size: 0.8em;" placeholder="{
  &quot;tournament_name&quot;: &quot;Tournoi BCNJ&quot;,
  &quot;sections&quot;: 1,
  &quot;auto_capture&quot;: true,
  &quot;capture_interval&quot;: 30,
  &quot;display_config&quot;: {
    &quot;dark_mode&quot;: false,
    &quot;font_size&quot;: 1.0,
    &quot;show_constraints&quot;: true
  }
}"></textarea>
                <button onclick="sendConfigToN8N()" style="background: #6f42c1; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-top: 8px;">
                    üì§ Envoyer Config
                </button>
                <button onclick="receiveConfigFromN8N()" style="background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-left: 8px;">
                    üì• R√©cup√©rer Config
                </button>
            `;
        }

        function triggerCapture() {
            const captureType = document.querySelector('input[name="captureType"]:checked').value;
            const width = document.getElementById('captureWidth').value;
            const height = document.getElementById('captureHeight').value;
            const webhook = document.getElementById('n8nWebhook').value;

            const captureConfig = {
                type: captureType,
                width: parseInt(width),
                height: parseInt(height),
                url: window.location.href,
                timestamp: new Date().toISOString(),
                tournament_data: {
                    pairs: parsedPairs.length,
                    sections: currentSectionCount,
                    constraints: Array.from(nsConstraints)
                }
            };

            if (webhook) {
                fetch(webhook, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(captureConfig)
                })
                .then(response => response.json())
                .then(data => {
                    alert('‚úì Capture d√©clench√©e via n8n!');
                })
                .catch(error => {
                    console.error('Erreur webhook:', error);
                    alert('‚úó Erreur webhook - utilisation locale');
                    captureScreenLocal(captureConfig);
                });
            } else {
                captureScreenLocal(captureConfig);
            }
        }

        function captureScreenLocal(config) {
            // Interface de capture locale via API browser
            if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                navigator.mediaDevices.getDisplayMedia({
                    video: {
                        width: config.width,
                        height: config.height
                    }
                })
                .then(stream => {
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.play();

                    video.addEventListener('loadedmetadata', () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = config.width;
                        canvas.height = config.height;
                        const ctx = canvas.getContext('2d');

                        ctx.drawImage(video, 0, 0, config.width, config.height);

                        canvas.toBlob(blob => {
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `bridge-capture-${new Date().toISOString().slice(0,19)}.png`;
                            a.click();

                            stream.getTracks().forEach(track => track.stop());
                        }, 'image/png');
                    });
                })
                .catch(err => {
                    console.error('Erreur capture:', err);
                    alert('‚úó Capture d\'√©cran non disponible dans ce navigateur');
                });
            } else {
                alert('‚úó API capture d\'√©cran non support√©e');
            }
        }

        function sendConfigToN8N() {
            const webhook = document.getElementById('configWebhook').value;
            const params = document.getElementById('configParams').value;

            if (!webhook) {
                alert('Veuillez saisir l\'URL du webhook n8n');
                return;
            }

            try {
                const config = JSON.parse(params);
                fetch(webhook, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'update_config',
                        config: config,
                        timestamp: new Date().toISOString()
                    })
                })
                .then(response => response.json())
                .then(data => {
                    alert('‚úì Configuration envoy√©e √† n8n!');
                })
                .catch(error => {
                    console.error('Erreur:', error);
                    alert('‚úó Erreur lors de l\'envoi');
                });
            } catch (e) {
                alert('‚úó JSON invalide dans la configuration');
            }
        }

        function receiveConfigFromN8N() {
            const webhook = document.getElementById('configWebhook').value;

            if (!webhook) {
                alert('Veuillez saisir l\'URL du webhook n8n');
                return;
            }

            fetch(webhook + '?action=get_config', {
                method: 'GET'
            })
            .then(response => response.json())
            .then(data => {
                if (data.config) {
                    document.getElementById('configParams').value = JSON.stringify(data.config, null, 2);
                    applyConfigFromN8N(data.config);
                    alert('‚úì Configuration r√©cup√©r√©e et appliqu√©e!');
                }
            })
            .catch(error => {
                console.error('Erreur:', error);
                alert('‚úó Erreur lors de la r√©cup√©ration');
            });
        }

        function applyConfigFromN8N(config) {
            if (config.display_config) {
                if (config.display_config.dark_mode && !document.body.classList.contains('dark-mode')) {
                    toggleDarkMode();
                }
                if (config.display_config.font_size && config.display_config.font_size !== 1.0) {
                    document.documentElement.style.fontSize = (config.display_config.font_size * 100) + '%';
                }
            }
            if (config.sections) {
                document.getElementById('sectionCount').value = config.sections;
            }
        }

        // Debug function to check display issues
        function debugDisplay() {
            console.log('üêõ DEBUG START ====================');
            console.log('Debug - Mitchell Data:', mitchellData);
            console.log('Debug - Parsed Pairs:', parsedPairs);
            console.log('Debug - Current Section Count:', currentSectionCount);
            console.log('Debug - Container:', document.getElementById('mitchellContainer'));
            console.log('Debug - Page Navigation:', document.getElementById('pageNavigation'));
            console.log('üêõ DEBUG END ======================');

            // Show alert to confirm debug ran
            alert(`Debug info logged to console:\n- Parsed pairs: ${parsedPairs.length}\n- Mitchell data: ${mitchellData.length}\n- Section count: ${currentSectionCount}`);
        }

        // Add debug info to generateSections
        function generateSectionsOriginal() {
            // Original function content here - keeping as backup
        }

        // Dark mode initialization
        function initializeDarkMode() {
            const shouldBeDark = localStorage.getItem('darkMode') === 'true';
            console.log('üåô Initializing dark mode, should be dark:', shouldBeDark);

            const body = document.body;
            const btn = document.getElementById('darkModeBtn');

            isDarkMode = shouldBeDark;

            if (shouldBeDark) {
                body.style.cssText = 'background-color: #1a1a1a !important; color: #e0e0e0 !important;';
                body.className = 'dark-mode';
                if (btn) btn.textContent = '‚òÄÔ∏è Light';
            } else {
                body.style.cssText = 'background-color: #ffffff !important; color: #000000 !important;';
                body.className = '';
                if (btn) btn.textContent = 'üåô Dark';
            }

            console.log('üåô Dark mode initialized, state:', isDarkMode);
        }

        // Initialize ASAP
        document.addEventListener('DOMContentLoaded', initializeDarkMode);

        // Test if button exists and force click handler
        setTimeout(() => {
            const btn = document.getElementById('darkModeBtn');
            if (btn) {
                console.log('üåô Button found, adding click handler');
                btn.onclick = forceDarkMode;
            }
        }, 1000);

        // Fix for missing display - ensure renderMitchellDisplay is called
        window.addEventListener('load', function() {
            // Auto-load test data for public display
            setTimeout(() => {
                initializePublicDisplay();
            }, 500);

            // Auto-debug on page load
            setTimeout(() => {
                if (parsedPairs.length > 0 && mitchellData.length === 0) {
                    console.warn('Warning: Parsed pairs exist but mitchell data is empty');
                    debugDisplay();
                }
            }, 1000);
        });

        // Initialize public display with test data
        function initializePublicDisplay() {
            console.log('üîç DEBUG: Initializing public display...');

            // Show Mitchell view and hide setup view
            document.getElementById('setupView').style.display = 'none';
            document.getElementById('mitchellView').style.display = 'block';

            // Load test data into hidden form
            document.getElementById('tournamentData').value = generateTestData();

            // Parse and generate sections
            generateSections();

            console.log('üîç DEBUG: Public display initialized');
        }

        // Add test data button
        function loadTestData() {
            document.getElementById('tournamentData').value = generateTestData();
            hideStatus();
            // Auto-generate sections after loading test data
            setTimeout(() => {
                generateSections();
            }, 100);
        }

        function loadTestData80() {
            document.getElementById('tournamentData').value = generateTestData80();
            hideStatus();
            // Auto-generate sections after loading test data
            setTimeout(() => {
                generateSections();
            }, 100);
        }

        // Auto-hide status on input
        document.getElementById('tournamentData').addEventListener('input', hideStatus);
        document.getElementById('sectionCount').addEventListener('change', hideStatus);

        // Add alternative event listeners for all buttons
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîç DEBUG: DOM loaded, setting up event listeners...');

            const generateBtn = document.getElementById('generateButton');
            if (generateBtn) {
                generateBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('üîç DEBUG: Generate button clicked via event listener');
                    generateSections();
                });
                console.log('‚úì Generate button event listener added');
            } else {
                console.error('‚ùå Generate button not found');
            }

            // Add event listeners to other buttons as backup
            const buttons = document.querySelectorAll('button[onclick]');
            buttons.forEach(button => {
                const onclickAttr = button.getAttribute('onclick');
                if (onclickAttr) {
                    button.addEventListener('click', function(e) {
                        console.log('üîç DEBUG: Button clicked (backup listener):', onclickAttr);
                        try {
                            eval(onclickAttr);
                        } catch (error) {
                            console.error('‚ùå Error executing onclick:', error);
                        }
                    });
                }
            });
            console.log('‚úì Backup event listeners added for', buttons.length, 'buttons');

            // Re-initialize dark mode after DOM is ready
            initializeDarkMode();
        });

        // Bookmarklet for FFB automation (user can drag this to bookmarks)
        function generateBookmarklet() {
            const script = `
                javascript:(() => {
                    const tables = document.querySelectorAll('table tr');
                    let data = '';
                    let currentDate = '';

                    tables.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 3) {
                            const dateCell = cells[0]?.textContent?.trim();
                            const player1Cell = cells[1]?.textContent?.trim();
                            const player2Cell = cells[2]?.textContent?.trim();

                            if (dateCell && dateCell.match(/\\d{2}\/\\d{2}\/\\d{4}/)) {
                                currentDate = dateCell;
                            }

                            if (player1Cell && player2Cell && currentDate) {
                                data += currentDate + '\\n';
                                data += player1Cell + '\\n';
                                data += player2Cell + '\\n';
                            }
                        }
                    });

                    if (data) {
                        const newWindow = window.open('${window.location.href}', '_blank');
                        newWindow.addEventListener('load', () => {
                            newWindow.document.getElementById('tournamentData').value = data;
                            newWindow.generateSections();
                        });
                    } else {
                        alert('Aucune donn√©e de tournoi trouv√©e sur cette page.');
                    }
                })();
            `;

            return script.replace(/\s+/g, ' ').trim();
        }
    </script>
</body>
</html>